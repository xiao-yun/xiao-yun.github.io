<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Common,Hadoop-1.2.1,Java,RPC,RPC源码阅读,源码阅读," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Hadoop版本:Hadoop-1.2.1参考：《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》,后文简称技术内幕RPC中用到的通道和选择器另见通道和选择器，缓冲区另见缓冲区,以及序列化(主要是ObjectWritable)另见序列化下文所说的[概述]为上篇RPC源码分析—概述本文不涉及SIMPLE，DIGEST，KERBEROS三种鉴权方式的鉴权过程分析">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC源码阅读---源码分析下篇">
<meta property="og:url" content="http://xiao-yun.github.io/RPC源码分析下篇/index.html">
<meta property="og:site_name" content="xiaoyun">
<meta property="og:description" content="Hadoop版本:Hadoop-1.2.1参考：《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》,后文简称技术内幕RPC中用到的通道和选择器另见通道和选择器，缓冲区另见缓冲区,以及序列化(主要是ObjectWritable)另见序列化下文所说的[概述]为上篇RPC源码分析—概述本文不涉及SIMPLE，DIGEST，KERBEROS三种鉴权方式的鉴权过程分析">
<meta property="og:image" content="http://xiao-yun.github.io/../images/markClosed.png">
<meta property="og:image" content="http://xiao-yun.github.io/../images/closeConnection.png">
<meta property="og:updated_time" content="2016-01-08T06:45:06.374Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RPC源码阅读---源码分析下篇">
<meta name="twitter:description" content="Hadoop版本:Hadoop-1.2.1参考：《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》,后文简称技术内幕RPC中用到的通道和选择器另见通道和选择器，缓冲区另见缓冲区,以及序列化(主要是ObjectWritable)另见序列化下文所说的[概述]为上篇RPC源码分析—概述本文不涉及SIMPLE，DIGEST，KERBEROS三种鉴权方式的鉴权过程分析">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide',
    motion: true
  };
</script>

  <title> RPC源码阅读---源码分析下篇 | xiaoyun </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?caeb4129c91d1e6fb3d562d35fedef0d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">xiaoyun</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                RPC源码阅读---源码分析下篇
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-08T14:45:06+08:00" content="2016-01-08">
              2016-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop-1-2-1/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop-1.2.1</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop-1-2-1/Common/" itemprop="url" rel="index">
                    <span itemprop="name">Common</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop-1-2-1/Common/RPC/" itemprop="url" rel="index">
                    <span itemprop="name">RPC</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop-1-2-1/Common/RPC/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop-1-2-1/Common/RPC/源码阅读/RPC源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">RPC源码阅读</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/RPC源码分析下篇/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="RPC源码分析下篇/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>Hadoop版本:<a href="https://archive.apache.org/dist/hadoop/core/hadoop-1.2.1/" target="_blank" rel="external">Hadoop-1.2.1</a><br>参考：《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》,后文简称技术内幕<br>RPC中用到的通道和选择器另见<a href="../通道和选择器">通道和选择器</a>，缓冲区另见<a href="../缓冲区">缓冲区</a>,以及序列化(主要是ObjectWritable)另见<a href="../序列化">序列化</a><br>下文所说的[概述]为上篇<a href="../RPC源码分析---概述">RPC源码分析—概述</a><br>本文不涉及SIMPLE，DIGEST，KERBEROS三种鉴权方式的鉴权过程分析</p>
<hr>
<p>本文所属<code>RPC源码分析</code>，按照调用请求的步骤对源码进行分析，限于篇幅分为上下两篇。  </p>
<p>上篇分析了”客户端代理创建”，”服务器创建启动”，”客户端服务器连接建立”，”客户端头数据发送”，”服务器对头数据验证，鉴权”，至此连接已经建立验证，可以发送正常的调用请求了。上篇另见<a href="../RPC源码分析上篇">RPC源码分析上篇</a>。  </p>
<p>而下篇分析了”客户端调用请求”，”服务器对调用请求的处理响应”，”客户端接收响应”，”客户端服务器连接的关闭”，”客户端关闭”，”服务器关闭”等过程，本文即为下篇。</p>
<hr>
<h2 id="1-_方法调用请求和响应">1. 方法调用请求和响应</h2><p>上篇<strong>&lt;建立连接&gt;</strong>部分分析了建立连接过程中，客户端的连接请求和头数据发送，服务器端的连接接收以及头数据处理鉴权等过程。</p>
<p>对于客户端来说<code>getConnection</code>返回时表明连接已经创建，且头数据已经发送，而关于服务器对头数据的异常响应在客户端Connection线程中。<br>对getConnection要注意的是，复用Connection时，如果连接已经建立且头数据已经发送<code>setupIOstreams</code>直接返回。<br>而对于服务器端来说，监听器的Reader线程已经处理了头数据，接下来等待实际的调用请求。  </p>
<p>下面分析客户端的实际调用请求和服务器对请求的响应</p>
<h3 id="1-1_客户端调用请求">1.1 客户端调用请求</h3><p>由上，<code>getConnection</code>之后，通过连接对象的<code>sendParam</code>方法发起调用请求，具体见前面分析<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.sendParam(<span class="operator"><span class="keyword">call</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>这里<code>call</code>为封装了<code>Invocation</code>的客户端调用对象<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> sendParam(<span class="keyword">Call</span> <span class="keyword">call</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldCloseConnection.get()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;<span class="comment">//对应的服务器端鉴权失败，客户端连接关闭，这里便取消发送调用请求</span></span><br><span class="line">  </span><br><span class="line">  DataOutputBuffer d=<span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.out) &#123;<span class="comment">//同步，使用该连接的输出流out，保证一次能够完整的输出一帧数据，而不会乱序</span></span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">        LOG.debug(getName() + <span class="string">" sending #"</span> + <span class="keyword">call</span>.id);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//for serializing the</span></span><br><span class="line">      <span class="comment">//data to be written</span></span><br><span class="line">      d = <span class="keyword">new</span> DataOutputBuffer();</span><br><span class="line">      d.writeInt(<span class="keyword">call</span>.id);<span class="comment">//id暂存到缓冲区</span></span><br><span class="line">      <span class="keyword">call</span>.param.<span class="keyword">write</span>(d);<span class="comment">//方法，参数信息的Invocation对象序列化暂存到缓冲区</span></span><br><span class="line">      <span class="keyword">byte</span>[] data = d.getData();</span><br><span class="line">      <span class="keyword">int</span> dataLength = d.getLength();</span><br><span class="line">      out.writeInt(dataLength);      <span class="comment">//first put the data length，先写缓冲区数据长度，即一帧数据大小</span></span><br><span class="line">      out.<span class="keyword">write</span>(data, <span class="number">0</span>, dataLength);<span class="comment">//write the data，然后写实际一帧的数据</span></span><br><span class="line">      out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    markClosed(e);<span class="comment">//写操作异常，服务器连接可能关闭，唤醒等待读取响应的该连接线程，并关闭</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//the buffer is just an in-memory buffer, but it is still polite to</span></span><br><span class="line">    <span class="comment">// close early</span></span><br><span class="line">    IOUtils.closeStream(d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，<code>sendParam</code>比较简单，一帧实际调用请求数据的输出格式为:<br><code>数据长度+实际数据(id+Invocation对象)</code><br>即数据长度，然后是客户端Call对象的id，服务器创建Call对象是id值便为此值，再就是包含请求的方法，方法参数信息的Invocation对象，服务器端只需相应的创建Invocation对象，然后反序列化即可。<br>需要注意的是，使用连接对象的输出流out进行的同步操作，这样能够保证多个线程使用sendParam发送调用请求时，一次能够完整的发送一整帧数据，而不会乱序。<br>同时，写操作异常时，需要关闭连接。  </p>
<p>调用请求发送完后，当前调用线程便阻塞等待，直到对应的Connection对象通知响应已经到达，具体见前面分析<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">call</span>.<span class="keyword">wait</span>();</span></span><br></pre></td></tr></table></figure></p>
<p>而响应到达时的通知，唤醒该睡眠线程见后面分析。  </p>
<h3 id="1-2_服务器端调用请求的响应">1.2 服务器端调用请求的响应</h3><h4 id="1-2-1_监听器处理">1.2.1 监听器处理</h4><p>继续承接前文监听器listener的Reader线程对到来数据的处理，前面已经分析了到来数据<code>rpcHeader</code>，<code>ConnectionHeader</code>和ping数据的处理过程。<br>具体到实际调用请求的数据处理，由前文可知由<code>processData</code>方法负责处理，调用链为:<br><code>doRead(key)-&gt;readAndProcess()-&gt;processOneRpc(data)-&gt;processData(buf)</code><br>此时，headerRead为true。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> processData(<span class="keyword">byte</span>[] buf) <span class="keyword">throws</span>  IOException, InterruptedException &#123;</span><br><span class="line">  DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(buf));</span><br><span class="line">  <span class="keyword">int</span> id = dis.readInt();                    <span class="comment">// try to read an id，读客户端Call对象id</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">    LOG.debug(<span class="string">" got #"</span> + id);</span><br><span class="line"></span><br><span class="line">  Writable param = ReflectionUtils.newInstance(paramClass, conf);<span class="comment">//read param，创建Invocation对象</span></span><br><span class="line">  param.readFields(dis);<span class="comment">//反序列化发送过来的Invocation</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">Call</span> <span class="keyword">call</span> = <span class="keyword">new</span> <span class="keyword">Call</span>(id, param, <span class="keyword">this</span>);<span class="comment">//创建服务器端Call对象</span></span><br><span class="line">  callQueue.put(<span class="keyword">call</span>);              <span class="comment">// queue the call; maybe blocked here，放入阻塞队列callQueue，等待处理器handler处理</span></span><br><span class="line">  incRpcCount();  <span class="comment">// Increment the rpc count，增加处理的rpc计数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据客户端实际调用请求发送数据格式，会先发送一帧数据的长度，这个长度在processData之前读取在dataLengthBuffer中，具体见前面分析。根据这个长度构建的data缓冲区，然后读取data缓冲区大小的数据，这里的<code>buf</code>参数便是data缓冲区中的数据。<br>客户端在发送长度之后，便是Call对象的id，因此先读取4个字节的id，然后是包含调用的方法，方法参数信息的Invocation对象，服务器同样的创建一个Invocation对象，进行反序列化。<br>之后构建服务器端的Call对象，与客户端的Call对象相对应，不过服务器端多了该Call对象所属的Connection这一成员。<br>创建的Call对象放入阻塞队列<code>callQueue</code>中等待handler进行处理，很明显的”生产者-消费者”模型。  </p>
<h4 id="1-2-2_处理器处理">1.2.2 处理器处理</h4><h5 id="1-2-2-1_主程序">1.2.2.1 主程序</h5><p>监听器，处理器和响应器都实在服务器创建后调用start启动的，处理器主程序如下:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">  LOG.info(getName() + <span class="string">": starting"</span>);</span><br><span class="line">  SERVER.set(Server.<span class="keyword">this</span>);</span><br><span class="line">  ByteArrayOutputStream buf = <span class="keyword">new</span> ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">Call</span> <span class="keyword">call</span> = callQueue.take(); <span class="comment">// pop the queue; maybe blocked here，从阻塞队列中取出一个Call对象</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">        LOG.debug(getName() + <span class="string">": has #"</span> + <span class="keyword">call</span>.id + <span class="string">" from "</span> + <span class="keyword">call</span>.connection);</span><br><span class="line">      </span><br><span class="line">      String errorClass = <span class="keyword">null</span>;</span><br><span class="line">      String error = <span class="keyword">null</span>;</span><br><span class="line">      Writable value = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      CurCall.set(<span class="keyword">call</span>);<span class="comment">//取出的Call对象保存在当前处理器线程的线程局部变量CurCall中</span></span><br><span class="line">      <span class="comment">//本地实现方法调用</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">call</span>.connection.user == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">call</span>(<span class="keyword">call</span>.connection.protocol, <span class="keyword">call</span>.param, <span class="keyword">call</span>.timestamp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          value = <span class="keyword">call</span>.connection.user.doAs(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Writable&gt;() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 <span class="keyword">public</span> Writable run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">call</span>(<span class="keyword">call</span>.connection.protocol, <span class="keyword">call</span>.param, <span class="keyword">call</span>.timestamp);</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ...<span class="comment">//日志记录</span></span><br><span class="line">        errorClass = e.getClass().getName();<span class="comment">//调用异常类</span></span><br><span class="line">        error = StringUtils.stringifyException(e);<span class="comment">//异常信息</span></span><br><span class="line">      &#125;</span><br><span class="line">      CurCall.set(<span class="keyword">null</span>);<span class="comment">//调用完成，清空CurCall</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">call</span>.connection.responseQueue) &#123;<span class="comment">//写到responseQueue中，同步</span></span><br><span class="line">        <span class="comment">//将调用结果(包括状态，正确返回值或异常)设置为call的response成员</span></span><br><span class="line">        setupResponse(buf, <span class="keyword">call</span>, (error == <span class="keyword">null</span>) ? Status.SUCCESS : Status.ERROR, value, errorClass, error);</span><br><span class="line">      <span class="keyword">if</span> (buf.<span class="keyword">size</span>() &gt; maxRespSize) &#123;<span class="comment">//上次响应太大，重新分配小的临时缓冲，以释放大块内存，因为一般来说响应都是比较小的</span></span><br><span class="line">        LOG.warn(<span class="string">"Large response size "</span> + buf.<span class="keyword">size</span>() + <span class="string">" for call "</span> + <span class="keyword">call</span>.toString());</span><br><span class="line">          buf = <span class="keyword">new</span> ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);<span class="comment">//重新分配10KB</span></span><br><span class="line">        &#125;</span><br><span class="line">        responder.doRespond(<span class="keyword">call</span>);<span class="comment">//将包含响应的Call对象添加到关联连接的响应队列responseQueue中，并做相应的处理</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//异常记录</span></span><br><span class="line">  &#125;</span><br><span class="line">  LOG.info(getName() + <span class="string">": exiting"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，处理器每次从<code>callQueue</code>阻塞队列中拿出一个待处理的Call对象，然后执行本地实现的调用处理。不管是鉴权方式还是普通的调用，最终都通过<code>call</code>方法执行方法的调用，调用结果可能为正常的返回值，此时封装在ObjectWritable中，可能发生异常，此时异常类记录在<code>errorClass</code>，异常信息记录在<code>error</code>中，然后将返回值或异常设置为call的响应，添加到连接的响应队列中等待处理。  </p>
<h5 id="1-2-2-2_call">1.2.2.2 call</h5><p>对应为实际本地实现的方法调用过程，<code>org.apache.hadoop.ipc.Server</code>中方法如下<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Writable <span class="keyword">call</span>(<span class="keyword">Class</span>&lt;?&gt; protocol, Writable param, <span class="keyword">long</span> receiveTime) <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure></p>
<p>为抽象方法，我们创建服务器时是创建<code>RPC.Server</code>即该类的实现类，实现如下:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">Writable</span> call(<span class="type">Class</span>&lt;?&gt; protocol, <span class="type">Writable</span> param, long receivedTime) throws <span class="type">IOException</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Invocation</span> call = (<span class="type">Invocation</span>)param;//<span class="type">Invocation</span>对象</span><br><span class="line">    <span class="keyword">if</span> (verbose) log(<span class="string">"Call: "</span> + call);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="keyword">method</span> = protocol.getMethod(call.getMethodName(),call.getParameterClasses());</span><br><span class="line">    <span class="keyword">method</span>.setAccessible(<span class="literal">true</span>);//设置方法可访问</span><br><span class="line"></span><br><span class="line">    long startTime = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">    <span class="type">Object</span> value = <span class="keyword">method</span>.invoke(instance, call.getParameters());//反射调用实例instance上的方法<span class="keyword">method</span>，参数在<span class="type">Invocation</span>中</span><br><span class="line">    <span class="type">int</span> processingTime = (<span class="type">int</span>) (<span class="type">System</span>.currentTimeMillis() - startTime);</span><br><span class="line">    <span class="type">int</span> qTime = (<span class="type">int</span>) (startTime-receivedTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">LOG</span>.isDebugEnabled()) &#123;//记录该<span class="type">Call</span>从接收到开始处理即在队列中的时间，以及处理时间</span><br><span class="line">      <span class="type">LOG</span>.debug(<span class="string">"Served: "</span> + call.getMethodName() + <span class="string">" queueTime= "</span> + qTime + <span class="string">" procesingTime= "</span> + processingTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ...//度量记录</span><br><span class="line">    //将返回值封装成<span class="type">ObjectWritable</span>返回</span><br><span class="line">    <span class="keyword">return</span> new <span class="type">ObjectWritable</span>(<span class="keyword">method</span>.getReturnType(), value);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ...//调用方法异常，进行日志记录并抛出，对应在handler线程中也会进行相应的日志记录，同时会记录异常类errorClass和异常信息error，将</span><br><span class="line">  //errorClass和error作为响应发送，状态为<span class="type">ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，从Invocation对象中取出调用的方法和参数信息，在我们创建服务器<code>getServer</code>时指定的实现协议的实例instance调用相应的方法即可，不过调用是通过反射执行。如果成功执行得到返回值，将返回值封装成ObjectWritable返回，而执行时出现异常则进行日志记录，并抛到上层，在handler线程中，记录日志并记录异常类和异常信息，最终会将异常类和异常信息作为响应发送到客户端，就像本地调用方法出现异常一样。  </p>
<p>call返回后，可能得到正常返回值，可能得到异常。接下来通过<code>setupResponse</code>把正常返回值或异常作为响应添加到Call对象中，有了响应的Call对象便可以发送给客户端了，添加至连接的响应队列中进行处理。  </p>
<h5 id="1-2-2-3_setupResponse">1.2.2.3 setupResponse</h5><p>调用结果添加至Call对象的响应成员中<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void setupResponse(ByteArrayOutputStream response, <span class="keyword">Call</span> <span class="keyword">call</span>, <span class="keyword">Status</span> <span class="keyword">status</span>, Writable rv, String errorClass, String error) </span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    response.reset();//重置ByteArrayOutputStream中字节数组，等待写入</span><br><span class="line">    DataOutputStream <span class="type">out</span> = new DataOutputStream(response);</span><br><span class="line">    <span class="type">out</span>.writeInt(<span class="keyword">call</span>.id);                // <span class="built_in">write</span> <span class="keyword">call</span> id，先写<span class="keyword">Call</span>的id</span><br><span class="line">    <span class="type">out</span>.writeInt(<span class="keyword">status</span>.state);           // <span class="built_in">write</span> <span class="keyword">status</span>，再写调用的状态，成功返回为SUCCESS(值为<span class="number">0</span>)，异常为ERROR(值为<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">status</span> == <span class="keyword">Status</span>.SUCCESS) &#123;//成功返回，写返回值ObjectWritable的序列化数据</span><br><span class="line">      rv.<span class="built_in">write</span>(<span class="type">out</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;//异常情况，先写异常类，再写异常信息</span><br><span class="line">      WritableUtils.writeString(<span class="type">out</span>, errorClass);</span><br><span class="line">      WritableUtils.writeString(<span class="type">out</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">call</span>.connection.useWrap) &#123;</span><br><span class="line">      wrapWithSasl(response, <span class="keyword">call</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">call</span>.setResponse(ByteBuffer.wrap(response.toByteArray()));//响应数据设置为<span class="keyword">call</span>的成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，响应格式为:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常返回:</span></span><br><span class="line"><span class="keyword">Call</span>对象id<span class="number">+0</span><span class="comment">(SUCCESS)</span>+ObjectWritable<span class="comment">(返回值)</span>序列化</span><br><span class="line"><span class="comment">//发生异常</span></span><br><span class="line"><span class="keyword">Call</span>对象id<span class="number">+1</span><span class="comment">(ERROR)</span>+异常类<span class="comment">(字符串序列化)</span>+异常信息<span class="comment">(字符串序列化)</span></span><br></pre></td></tr></table></figure></p>
<p>还有另外一种响应FATAL，前面已经介绍过了，发生在客户端发送过来头部数据，服务器鉴权失败时。这时，对应的Call对象是固定的，其id为-1，响应格式:<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">-1<span class="params">(id)</span>+-1<span class="params">(<span class="variable">FATAL</span>)</span>+异常类<span class="params">(字符串序列化)</span>+异常信息<span class="params">(字符串序列化)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="1-2-2-4_doRespond">1.2.2.4 doRespond</h5><p>将包含响应的Call对象添加到连接的响应队列中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void doRespond(<span class="operator"><span class="keyword">Call</span> <span class="keyword">call</span>) throws IOException &#123;</span><br><span class="line">  synchronized (<span class="keyword">call</span>.<span class="keyword">connection</span>.responseQueue) &#123;</span><br><span class="line">    <span class="keyword">call</span>.<span class="keyword">connection</span>.responseQueue.addLast(<span class="keyword">call</span>);</span>//添加到队列尾</span><br><span class="line">    if (<span class="operator"><span class="keyword">call</span>.<span class="keyword">connection</span>.responseQueue.<span class="keyword">size</span>() == <span class="number">1</span>) &#123;//如果队列中只有一个待发送响应的<span class="keyword">Call</span>对象，直接在本线程中发送</span><br><span class="line">      processResponse(<span class="keyword">call</span>.<span class="keyword">connection</span>.responseQueue, <span class="literal">true</span>);</span>//发送<span class="operator"><span class="keyword">call</span>响应</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如上，将包含响应的Call对象添加到关联连接的响应队列responseQueue队列尾，如果队列中只有一个元素，则直接在本线程(handler)中发送响应，而不是等待响应器responder发送。  </p>
<h5 id="1-2-2-5_processResponse">1.2.2.5 processResponse</h5><p>处理响应队列中待发送响应的Call对象，该方法在handler和responder中都可能被调用，当响应队列中只有一个元素时，直接在handler线程中发送该响应，节省了切换到responder线程的开销。同时，当在handler中响应没有发送完，才会将连接对应的通道注册到responder的选择器中，注册选操作。  </p>
<p>在handler线程中的响应发送，对应的<code>inHandler</code>参数为true<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> processResponse(LinkedList&lt;<span class="keyword">Call</span>&gt; responseQueue, <span class="keyword">boolean</span> inHandler) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">boolean</span> error = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">boolean</span> done = <span class="keyword">false</span>;       <span class="comment">// there is more data for this channel.</span></span><br><span class="line">  <span class="keyword">int</span> numElements = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">Call</span> <span class="keyword">call</span> = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (responseQueue) &#123;</span><br><span class="line">      numElements = responseQueue.<span class="keyword">size</span>();</span><br><span class="line">      <span class="keyword">if</span> (numElements == <span class="number">0</span>) &#123;</span><br><span class="line">        error = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;              <span class="comment">//连接上没有待发送的响应</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">call</span> = responseQueue.removeFirst();<span class="comment">//获取响应队列的首元素</span></span><br><span class="line">      SocketChannel channel = <span class="keyword">call</span>.connection.channel;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(getName() + <span class="string">": responding to #"</span> + <span class="keyword">call</span>.id + <span class="string">" from "</span> + <span class="keyword">call</span>.connection);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//尽可能将call.response响应数据全部写到通道，但不保证</span></span><br><span class="line">      <span class="keyword">int</span> numBytes = channelWrite(channel, <span class="keyword">call</span>.response);</span><br><span class="line">      <span class="keyword">if</span> (numBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">call</span>.response.hasRemaining()) &#123;<span class="comment">//该响应已经全部发送玩</span></span><br><span class="line">        <span class="keyword">call</span>.connection.decRpcCount();<span class="comment">//减少该连接的rpc计数</span></span><br><span class="line">        <span class="keyword">if</span> (numElements == <span class="number">1</span>) &#123;    <span class="comment">// last call fully processes.</span></span><br><span class="line">          done = <span class="keyword">true</span>;             <span class="comment">// no more data for this channel.该连接所有响应已经发送完</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          done = <span class="keyword">false</span>;            <span class="comment">// more calls pending to be sent.该连接还有未发送的响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(getName() + <span class="string">": responding to #"</span> + <span class="keyword">call</span>.id + <span class="string">" from "</span> + <span class="keyword">call</span>.connection + <span class="string">" Wrote "</span> + numBytes + <span class="string">" bytes."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//响应数据这次没有发送完，添加到响应队列的队列首，等待下次发送。如果是在handler线程中发送的响应，则还需将连接对应通道注册到</span></span><br><span class="line">        <span class="comment">//responder选择器中，而如果是在responder中发送，则已经注册过了，无需再注册</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">call</span>.connection.responseQueue.addFirst(<span class="keyword">call</span>);<span class="comment">//添加到队列首</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (inHandler) &#123;</span><br><span class="line">          <span class="comment">// set the serve time when the response has to be sent later</span></span><br><span class="line">          <span class="keyword">call</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//如果responder线程阻塞在select操作，唤醒，然后休眠等待通道注册</span></span><br><span class="line">          </span><br><span class="line">          incPending();<span class="comment">//增加排队计数，这会造成responder在下次循环中等待通道注册</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            writeSelector.wakeup();<span class="comment">//如果responder阻塞在select操作上，唤醒</span></span><br><span class="line">            <span class="comment">//注册通道在responder选择器上，写操作，call对象作为附件附加在SelectionKey上</span></span><br><span class="line">            channel.register(writeSelector, SelectionKey.OP_WRITE, <span class="keyword">call</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">            <span class="comment">//Its ok. channel might be closed else where.</span></span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            decPending();<span class="comment">//注册完成，减少排队计数，唤醒等待注册完成的responder线程</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      error = <span class="keyword">false</span>;              <span class="comment">// everything went off well</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;<span class="comment">//发送响应过程中出错，关闭连接，可能情况为channelWrite过程中服务器关闭，中断该线程</span></span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; <span class="keyword">call</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">      LOG.warn(getName()+<span class="string">", call "</span> + <span class="keyword">call</span> + <span class="string">": output error"</span>);</span><br><span class="line">      done = <span class="keyword">true</span>;               <span class="comment">// error. no more data for this channel.</span></span><br><span class="line">      closeConnection(<span class="keyword">call</span>.connection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，该函数返回true时，表明连接的响应队列中没有待发送的响应(已经全部发送完)。<br>从响应队列首中取出待发送响应的Call对象，通过<code>channelWrite</code>尽可能的将响应发送到客户端，如果发送完了，减少连接上的rpc计数，连接上没有待发送响应时，直接返回true。<br>channelWrite和之前介绍过得channelRead类似，一次最多往通道写<code>NIO_BUFFER_LIMIT</code>即8KB大小的数据<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> channelWrite(WritableByteChannel channel, ByteBuffer buffer) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> =  (buffer.remaining() &lt;= NIO_BUFFER_LIMIT) ?</span><br><span class="line">                 channel.<span class="keyword">write</span>(buffer) : channelIO(<span class="keyword">null</span>, channel, buffer);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      rpcMetrics.incrSentBytes(<span class="keyword">count</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>channelIO</code>在前面channelRead中已经分析过了，这里<code>readCh</code>为null。</p>
<p>而如果没发送完，则需等待下次发送。如果现在是在handler线程中响应没有发送完，则将Call添加回响应队列的队列首，同时将通道注册到responder的选择器中，注册写操作，之后新的包含响应的Call对象添加到响应队列时，队列中元素不为1，不会在handler线程中处理，因此注册后的响应写由responder负责。<br>不过考虑这种情况，注册后由responder负责响应写，而所有响应写完之后客户端暂时没有新的请求，导致响应队列元素为空。过了一段时间，客户端再次请求新的包含响应的Call对象添加到响应队列，添加后队列元素为1，应该由handler线程处理，那这时responder还是注册了通道的写操作就会有问题了，因此在responder中，如果连接上所有的响应发送完，要取消该连接通道上的写操作注册<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> doAsyncWrite(SelectionKey key) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">Call</span> <span class="keyword">call</span> = (<span class="keyword">Call</span>)key.attachment();<span class="comment">//通过SelectionKey的附件获取Call对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">call</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key.channel() != <span class="keyword">call</span>.connection.channel) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"doAsyncWrite: bad channel"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">call</span>.connection.responseQueue) &#123;<span class="comment">//call对象关联的</span></span><br><span class="line">    <span class="keyword">if</span> (processResponse(<span class="keyword">call</span>.connection.responseQueue, <span class="keyword">false</span>)) &#123;<span class="comment">//返回true时，表示连接上所有响应已经发送完</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        key.interestOps(<span class="number">0</span>);<span class="comment">//取消写操作的注册</span></span><br><span class="line">      &#125;</span><br><span class="line">      ...<span class="comment">//异常记录</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法在responder线程的主程序中被调用，因此如果已经通道已经注册了responder上选择器写操作，由responder负责连接上响应的发送时，当所有响应发送完后，需要取消写操作的注册，以便下一个Call对象添加到响应队列中时，能够在handler线程中处理并做相应的注册。  </p>
<p>而通道的注册，通过<code>incPending</code>和<code>writeSelector.wakeup</code>的配合暂停responder的工作，注册时将Call对象作为附件附加在SelectionKey上，注册完后通过<code>decPending</code>唤醒responder线程，具体的注册过程见后面responder的主程序分析。</p>
<p>如果现在是在responder线程中响应没有发送完，则将Call添加回响应队列首即可，因为已经注册了。  </p>
<h4 id="1-2-3_响应器处理">1.2.3 响应器处理</h4><p>如上分析，对于包含响应的Call对象，添加到连接的相应队列中后，可能在handler线程中直接处理，而如果handler线程处理不过来，则需要将通道注册到responder选择器中，然后交由responder处理。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">  LOG.info(getName() + <span class="string">": starting"</span>);</span><br><span class="line">  SERVER.set(Server.<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">long</span> lastPurgeTime = <span class="number">0</span>;   <span class="comment">// last check for old calls.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      waitPending();     <span class="comment">//如果现在有通道正在注册，休眠等待</span></span><br><span class="line">      writeSelector.select(PURGE_INTERVAL);<span class="comment">//最多阻塞15min</span></span><br><span class="line">      Iterator&lt;SelectionKey&gt; iter = writeSelector.selectedKeys().iterator();</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iter.<span class="keyword">next</span>();</span><br><span class="line">        iter.remove();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isWritable()) &#123;<span class="comment">//通道可写</span></span><br><span class="line">              doAsyncWrite(key);<span class="comment">//写相应通道上的响应</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          LOG.info(getName() + <span class="string">": doAsyncWrite threw exception "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">if</span> (now &lt; lastPurgeTime + PURGE_INTERVAL) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;<span class="comment">//还没到清理时间，继续</span></span><br><span class="line">      &#125;</span><br><span class="line">      lastPurgeTime = now;<span class="comment">//应该清理了，更新lastPurgeTime</span></span><br><span class="line"></span><br><span class="line">      LOG.debug(<span class="string">"Checking for old call responses."</span>);</span><br><span class="line">      ArrayList&lt;<span class="keyword">Call</span>&gt; calls;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// get the list of channels from list of keys.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (writeSelector.keys()) &#123;<span class="comment">//获取注册时SelectionKey的合适附件Call对象</span></span><br><span class="line">        calls = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">Call</span>&gt;(writeSelector.keys().<span class="keyword">size</span>());</span><br><span class="line">        iter = writeSelector.keys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">          SelectionKey key = iter.<span class="keyword">next</span>();</span><br><span class="line">          <span class="keyword">Call</span> <span class="keyword">call</span> = (<span class="keyword">Call</span>)key.attachment();</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">call</span> != <span class="keyword">null</span> &amp;&amp; key.channel() == <span class="keyword">call</span>.connection.channel) &#123; </span><br><span class="line">            calls.add(<span class="keyword">call</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">Call</span> <span class="keyword">call</span> : calls) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          doPurge(<span class="keyword">call</span>, now);<span class="comment">//清理该Call所属连接上的相应长时间未发送的Call对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          LOG.warn(<span class="string">"Error in purging old calls "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// we can run out of memory if we have too many threads</span></span><br><span class="line">      <span class="comment">// log the event and sleep for a minute and give</span></span><br><span class="line">      <span class="comment">// some thread(s) a chance to finish</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      LOG.warn(<span class="string">"Out of Memory in server select"</span>, e);</span><br><span class="line">      <span class="comment">//内存不足，休眠1min等待资源释放</span></span><br><span class="line">      <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">60000</span>); &#125; <span class="keyword">catch</span> (Exception ie) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">"Exception in Responder "</span> + StringUtils.stringifyException(e));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LOG.info(<span class="string">"Stopping "</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，首先会进行可能的休眠状态，以等待通道的注册。注册完成后，使用<code>doAsyncWrite</code>对每一个可写通道，写出一个响应。本次相应处理完后，根据清理周期，对存在长时间没有发送的响应的连接进行清理，关闭该连接，通过<code>doPurge</code>完成。  </p>
<h5 id="1-2-3-1_等待通道注册">1.2.3.1 等待通道注册</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">waitPending</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (pending &gt; <span class="number">0</span>) &#123;<span class="comment">//循环判断，一个通道注册完后wait返回，如果还有其他通道再注册，醒来之后继续休眠等待，直到所有注册完成</span></span><br><span class="line">    wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pending为目前正在注册的通道数目，大于0时，休眠等待通道注册，对应为前面的handler中对未发送完响应的注册过程。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...<span class="comment">//见前面processResponse方法</span></span><br><span class="line">incPending();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    writeSelector.wakeup();</span><br><span class="line">    channel.register(writeSelector, SelectionKey.OP_WRITE, call);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">    done = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    decPending();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">incPending</span><span class="params">()</span> </span>&#123;   <span class="comment">// call waiting to be enqueued.</span></span><br><span class="line">  pending++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，incPending增加pending的值，然后wakeup唤醒可能阻塞在select操作上的responder线程(最多可能阻塞15min呢，所以需要唤醒)，下一次循环中便会在waitPending中休眠等待了。<br>注册完后decPending唤醒等待的responder<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">decPending</span><span class="params">()</span> </span>&#123; <span class="comment">// call done enqueueing.</span></span><br><span class="line">  pending--;</span><br><span class="line">  notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即减少pending值，并使得responder线程从wait中返回，而如果还有其他通道再注册，继续休眠。</p>
<h5 id="1-2-3-2_doAsyncWrite">1.2.3.2 doAsyncWrite</h5><p>等待通道注册完成后，便通过<code>doAsyncWrite</code>将可写的响应写到通道中，doAsyncWrite在前面已经分析过了，这里对应的<code>inHandler</code>为false，响应一次没发送完时，无需再次注册。注意的是，连接的响应队列中没有未发送的响应时，取消注册该通道的写操作，以便接下来的包含响应的Cal对象首先在handler中处理然后注册。  </p>
<p>由上doAsyncWrite的分析可知，一次doAsyncWrite只处理key所属连接响应队列中的一个待发送响应，所以responder的一次处理中，会对注册在其选择器上的每个可写通道发送一个未发送的响应。  </p>
<h5 id="1-2-3-3_doPurge">1.2.3.3 doPurge</h5><p>如果达到清理周期，对注册时每一个合法Call所属的连接，进行可能的清理工作<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> doPurge(<span class="keyword">Call</span> <span class="keyword">call</span>, <span class="keyword">long</span> now) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  LinkedList&lt;<span class="keyword">Call</span>&gt; responseQueue = <span class="keyword">call</span>.connection.responseQueue;<span class="comment">//call所属连接的响应队列</span></span><br><span class="line">  <span class="keyword">synchronized</span> (responseQueue) &#123;</span><br><span class="line">    Iterator&lt;<span class="keyword">Call</span>&gt; iter = responseQueue.listIterator(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">call</span> = iter.<span class="keyword">next</span>();</span><br><span class="line">      <span class="comment">//从接收到调用请求起到现在时间超过了PURGE_INTERVAL(15min)，该请求的响应还未发送给客户端，关闭所在的连接</span></span><br><span class="line">      <span class="keyword">if</span> (now &gt; <span class="keyword">call</span>.timestamp + PURGE_INTERVAL) &#123;</span><br><span class="line">        closeConnection(<span class="keyword">call</span>.connection);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，如果call所在连接的响应队列中存在超过清理周期的Call对象，即从接收到该调用请求到现在，已经过去了<code>PURGE_INTERVAL</code>(15min)，响应还没发送，则关闭所在的连接。<br>responder中每进行一次发送响应的操作后，如果到了清理时间，会对每一个连接进行判断，如果连接上存在长时间(15min)未发送的响应，则关闭所在的连接。<br>关闭连接后，客户端在读取响应的过程中，要么读超时异常，要么发送ping异常(通道关闭了)，导致客户端连接关闭，具体已经在前面分析过了。  </p>
<p>上面分析了建立连接后，客户端调用请求以及服务器端对请求的响应过程，下面分析客户端的响应接收过程。</p>
<hr>
<h2 id="2-_客户端接收响应">2. 客户端接收响应</h2><p>由前面分析知，客户端建立连接，发送头部数据后，开始发送调用请求数据，调用请求数据发送后，阻塞等待连接线程通知响应已经接收，然后返回。<br>Connection线程在<code>setupIOstreams</code>，建立连接，发送rpcHeader，发送ConnectionHeader后启动。看Connection线程的主程序<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="built_in">run</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled())</span><br><span class="line">    <span class="built_in">LOG</span>.debug(getName() + <span class="string">": starting, having connections "</span> + connections.size())<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (waitForWork()) &#123;//wait here <span class="keyword">for</span> work - read <span class="literal">or</span> close connection</span><br><span class="line">    receiveResponse()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  close()<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled())</span><br><span class="line">    <span class="built_in">LOG</span>.debug(getName() + <span class="string">": stopped, remaining connections "</span> + connections.size())<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，<code>waitForWork</code>返回true时，可以读取响应，然后通过<code>receiveResponse</code>读取响应。而waitForWork为false时，退出循环，关闭连接。  </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="built_in">boolean</span> waitForWork() &#123;</span><br><span class="line">  <span class="comment">//连接正常，不过没有远程调用等待接收响应，此时会等待一定时间，若该连接空闲时间超过maxIdleTime，则关闭连接</span></span><br><span class="line">  <span class="keyword">if</span> (calls.isEmpty() &amp;&amp; !shouldCloseConnection.<span class="built_in">get</span>()  &amp;&amp; running.<span class="built_in">get</span>())  &#123;</span><br><span class="line">    <span class="keyword">long</span> timeout = maxIdleTime- (System.currentTimeMillis()-lastActivity.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (timeout&gt;<span class="number">0</span>) &#123;<span class="comment">//还未达到最大空闲时间，等待</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        wait(timeout);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//连接正常且存在远程调用等待接收响应，返回true，开始接收响应</span></span><br><span class="line">  <span class="keyword">if</span> (!calls.isEmpty() &amp;&amp; !shouldCloseConnection.<span class="built_in">get</span>() &amp;&amp; running.<span class="built_in">get</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldCloseConnection.<span class="built_in">get</span>()) &#123;<span class="comment">//连接被标记为关闭，返回false，关闭</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (calls.isEmpty()) &#123; <span class="comment">// idle connection closed or stopped，长时间空闲，关闭连接</span></span><br><span class="line">    markClosed(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// get stopped but there are still pending requests </span></span><br><span class="line">    markClosed((IOException)<span class="keyword">new</span> IOException().initCause(<span class="keyword">new</span> InterruptedException()));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，其实客户端运行且连接没有被标记未关闭的话，如果calls有元素即存在等待读取响应的调用，则返回true，开始接收响应。<br>而如果该连接长时间(ipc.client.connection.maxidletime，默认10s)空闲，则会通过<code>markClosed</code>关闭连接。<br>也可以通过其他方式设置<code>shouldCloseConnection</code>为true关闭连接。</p>
<p>当存在等待接收响应的Call对象且连接正常时，通过<code>receiveResponse</code>接收一个响应。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void receiveResponse() &#123;</span><br><span class="line">    if (shouldCloseConnection.get()) &#123;//如果通知关闭连接，直接返回</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    touch();//更新连接的活动时间lastActivity</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        int id = <span class="keyword">in</span>.readInt();                    // try <span class="keyword">to</span> read an id，读C<span class="literal">all</span> id</span><br><span class="line">        </span><br><span class="line">        if (LOG.isDebugEnabled())</span><br><span class="line">          LOG.<span class="keyword">debug</span>(getName() + <span class="string">" got value #"</span> + id);</span><br><span class="line">        </span><br><span class="line">        C<span class="literal">all</span> call = calls.get(id);//获取等待读取相应的C<span class="literal">all</span>对象</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">state</span> = <span class="keyword">in</span>.readInt();     // read call status，读取调用状态</span><br><span class="line">        if (<span class="keyword">state</span> == Status.SUCCESS.<span class="keyword">state</span>) &#123;//成功，创建ObjectWritable对象，反序列化</span><br><span class="line">          Writable value = ReflectionUtils.newInstance(valueClass, conf);</span><br><span class="line">          value.readFields(<span class="keyword">in</span>);                 // read value，反序列化</span><br><span class="line">          call.<span class="built_in">set</span>Value(value);//设置call的响应，并通知之前阻塞等待结果的线程</span><br><span class="line">          calls.remove(id);//调用完成，从calls中移除</span><br><span class="line">        &#125; else if (<span class="keyword">state</span> == Status.ERROR.<span class="keyword">state</span>) &#123;//错误，分别读取异常类和异常信息</span><br><span class="line">          //设置call的异常，通知之前阻塞等待结果的线程</span><br><span class="line">          call.<span class="built_in">set</span>Exception(new RemoteException(WritableUtils.readString(<span class="keyword">in</span>), WritableUtils.readString(<span class="keyword">in</span>)));</span><br><span class="line">          calls.remove(id);//调用完成，从calls中移除</span><br><span class="line">        &#125; else if (<span class="keyword">state</span> == Status.FATAL.<span class="keyword">state</span>) &#123;//致命错误，鉴权失败时发生，关闭连接</span><br><span class="line">          // Close the connection，关闭连接</span><br><span class="line">          markClosed(new RemoteException(WritableUtils.readString(<span class="keyword">in</span>), WritableUtils.readString(<span class="keyword">in</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;//读取过程中发生异常，或者是read超时(rpcTimeout大于<span class="number">0</span>)，或者发送ping时异常，服务器连接关闭，因此关闭连接</span><br><span class="line">        markClosed(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，读取响应的过程，要结合服务器发送相应的格式来看，在前面<code>setupResponse</code>的分析中。<br>首先读取4个字节Call的id，从当前连接的calls中找到对应的Call对象，然后读取一个字节的状态。成功时，创建ObjectWritable反序列化即为调用返回值，错误时，分别反序列化两个字符串为异常类和异常信息，即为调用过程中抛出的异常，而致命错误时，直接关闭连接，关闭连接的异常也通过序列化异常类和异常信息得到。  </p>
<p>在获取到返回值后，通过<code>setValue</code>设置该Call的返回值，而获取到抛出异常后，通过setException设置该Call的异常。两者都会唤醒之前阻塞等待响应的线程(sendParam之后wait)<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Writable value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;<span class="comment">//设置返回值</span></span><br><span class="line">  callComplete();<span class="comment">//调用完成，通知阻塞线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">setException</span><span class="params">(IOException <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">error</span> = <span class="keyword">error</span>;<span class="comment">//设置异常</span></span><br><span class="line">  callComplete();<span class="comment">//调用完成，通知阻塞线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">callComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.done = <span class="keyword">true</span>;</span><br><span class="line">  notify();                                 <span class="comment">// notify caller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>callComplete</code>要结合之前的调用请求看，在前面&lt;代理方法调用&gt;部分。即通过代理调用方法时，转发到Invoker对象的invoke方法中，最终在Client的call方法中调用，在发送完调用请求后，阻塞等待Connection线程通知响应已经接收<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Writable <span class="keyword">call</span>(Writable param, ConnectionId remoteId) <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">    <span class="keyword">Call</span> <span class="keyword">call</span> = <span class="keyword">new</span> <span class="keyword">Call</span>(param);</span><br><span class="line">    Connection connection = getConnection(remoteId, <span class="keyword">call</span>);</span><br><span class="line">    connection.sendParam(<span class="keyword">call</span>);                 <span class="comment">// send the parameter，发送调用请求</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">call</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">call</span>.done) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">call</span>.wait();                           <span class="comment">// wait for the result，阻塞等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">          <span class="comment">// save the fact that we were interrupted</span></span><br><span class="line">          interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...<span class="comment">//处理异常和返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，callComplete中的notify便通知在对应call对象上调用wait方法的线程，使得从wait方法中返回，而此时call.done为true，从循环中退出。<br>之后便是对异常和返回值的处理，如果call.error不为null抛出异常，就像本地方法调用抛出异常一样。否则将call.value返回，就像本地方法调用返回值一样。<br>该call函数为Client在Invoker的invoke函数调用的，是代理转发，这样返回值或者异常便会转发给代理调用方法处，完成远程调用的过程。  </p>
<hr>
<h2 id="3-_连接的关闭">3. 连接的关闭</h2><p>前面分析了整个远程调用过程中客户端和服务器的行为，那么客户端和服务器端的连接什么情况下会关闭呢。  </p>
<h3 id="3-1_客户端连接关闭">3.1 客户端连接关闭</h3><p>客户端连接的关闭通过<code>Connection.close()</code>方法完成<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void <span class="keyword">close</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldCloseConnection.<span class="literal">get</span>()) &#123;<span class="comment">//应该已经设置了</span></span><br><span class="line">    <span class="keyword">LOG</span>.<span class="keyword">error</span>(<span class="string">"The connection is not in the closed state"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// release the resources</span></span><br><span class="line">  <span class="comment">// first thing to do;take the connection out of the connection list</span></span><br><span class="line">  synchronized (connections) &#123;<span class="comment">//从客户端维护的connections中移除</span></span><br><span class="line">    <span class="keyword">if</span> (connections.<span class="literal">get</span>(remoteId) == this) &#123;</span><br><span class="line">      connections.remove(remoteId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// close the streams and therefore the socket</span></span><br><span class="line">  IOUtils.closeStream(<span class="keyword">out</span>);<span class="comment">//关闭输出流</span></span><br><span class="line">  IOUtils.closeStream(<span class="keyword">in</span>);<span class="comment">//关闭输入流</span></span><br><span class="line">  disposeSasl();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clean up all calls</span></span><br><span class="line">  <span class="keyword">if</span> (closeException == null) &#123;<span class="comment">//这里只有在连接长时间空闲时可能为null，对应在waitForWork中的calls.isEmpty</span></span><br><span class="line">    <span class="keyword">if</span> (!calls.isEmpty()) &#123;<span class="comment">//一般来说calls为空，如果不为空，创建新的closeException</span></span><br><span class="line">      <span class="keyword">LOG</span>.warn(</span><br><span class="line">          <span class="string">"A connection is closed for no cause and calls are not empty"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// clean up calls anyway</span></span><br><span class="line">      closeException = new IOException(<span class="string">"Unexpected closed connection"</span>);</span><br><span class="line">      cleanupCalls();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">LOG</span>.debug(<span class="string">"closing ipc connection to "</span> + server + <span class="string">": "</span> + closeException.getMessage(),closeException);</span><br><span class="line">    &#125;</span><br><span class="line">    cleanupCalls();<span class="comment">//清理所有的call</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">LOG</span>.isDebugEnabled())</span><br><span class="line">    <span class="keyword">LOG</span>.debug(getName() + <span class="string">": closed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上连接关闭时，首先从客户端的connections中移除，然后关闭输入输出流，关闭socket，最后清理连接管理的所有Call<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> cleanupCalls() &#123;</span><br><span class="line">  <span class="type">Iterator</span>&lt;<span class="type">Entry</span>&lt;<span class="type">Integer</span>, <span class="type">Call</span>&gt;&gt; itor = calls.entrySet().<span class="keyword">iterator</span>() ;</span><br><span class="line">  <span class="keyword">while</span> (itor.hasNext()) &#123;</span><br><span class="line">    <span class="type">Call</span> c = itor.next().getValue(); </span><br><span class="line">    c.setException(closeException); // local exception，通过setException设置异常，唤醒等待响应的线程，完成调用</span><br><span class="line">    itor.remove();         </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，通过setException设置异常，唤醒等待响应的线程，因此该调用会抛出对应的关闭异常作为调用结果。  </p>
<p>在close方法中，shouldCloseConnection为true，其实关闭连接前，都会先调用markClosed方法设置该值为true。看看markClosed在哪里被调用:<br><img src="../images/markClosed.png" alt="markClosed">  </p>
<ul>
<li>receiveResponse<ul>
<li>第一处，读取到远端响应状态为FATAL，致命错误，此时验证或鉴权失败，应该关闭连接，服务器端对应也关闭连接；</li>
<li>第二处，是在读取响应过程中抛出IOException，包含三种可能情况:<ul>
<li>rpcTimeout大于0时，读操作超时，直接抛出I/O异常，关闭连接；</li>
<li>rpcTimeout不大于0时,读操作超时，会发送ping数据维持连接，若发送ping数据异常(对端已关闭连接，可能服务器连接中有长时间15min没发送响应的Call，清理过程中关闭了该连接，或者服务器死了等)，抛出I/O异常，关闭连接；</li>
<li><del>客户端关闭，通过中断连接线程，则读操作中会抛出InterruptedException，关闭连接；</del> 这里客户端关闭导致该线程中断时，不会抛出InterruptedException，因为底层的输入流要么是socket.getInputStream，要么是创建对应的SocketInputStream，读操作会一直阻塞直到上面两种情况发生。所以这里会不会有问题。</li>
</ul>
</li>
</ul>
</li>
<li>sendParam<br>在写操作中I/O异常，服务器端连接已关闭，可能为清理过程关闭了该连接，或者服务器死了，关闭连接；</li>
<li>setupIOstreams  <ul>
<li>第一处，IOException，可能主要有以下情况:<ul>
<li>连接服务器超时次数达到限制；</li>
<li>连接服务器其他异常；</li>
<li>获取输入输出流异常；</li>
<li>发送rpcHeader和ConnectionHeader过程中的写操作异常；</li>
<li>鉴权相关异常;</li>
</ul>
</li>
<li>第二处，其他异常，主要包括鉴权相关的异常以及中断异常；</li>
</ul>
</li>
<li>waitForWork<ul>
<li>第一处，连接长时间(默认10s)空闲，关闭连接；</li>
<li>第二处，客户端关闭，关闭连接；与上面receiveResponse中处于读操作时，客户端关闭不一样，此时连接线程处于waitForWork的判断逻辑中。  </li>
</ul>
</li>
</ul>
<h3 id="3-2_服务器连接的关闭">3.2 服务器连接的关闭</h3><p>服务器连接关闭由closeConnection完成<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionList) &#123;<span class="comment">//从服务器的连接列表中移除</span></span><br><span class="line">      <span class="keyword">if</span> (connectionList.remove(connection))</span><br><span class="line">        numConnections--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      connection.close();<span class="comment">//关闭该连接</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  disposeSasl();</span><br><span class="line">  data = <span class="keyword">null</span>;<span class="comment">//释放data缓冲区</span></span><br><span class="line">  dataLengthBuffer = <span class="keyword">null</span>;<span class="comment">//释放dataLengthBuffer缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (!channel.isOpen())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;socket.shutdownOutput();&#125; <span class="keyword">catch</span>(Exception e) &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (channel.isOpen()) &#123;<span class="comment">//关闭通道</span></span><br><span class="line">    <span class="keyword">try</span> &#123;channel.close();&#125; <span class="keyword">catch</span>(Exception e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;socket.close();&#125; <span class="keyword">catch</span>(Exception e) &#123;&#125;<span class="comment">//关闭socket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，首先从服务器的连接列表中移除，然后释放使用的缓冲区，关闭通道，关闭socket，即完成连接的关闭。  </p>
<p>closeConnection在以下地方被调用:<br><img src="../images/closeConnection.png" alt="closeConnection">  </p>
<ul>
<li><p>cleanupConnection和closeCurrentConnection<br>在listener线程的主程序异常处理程序中使用</p>
  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    ...<span class="comment">//选择器上的select操作等</span></span><br><span class="line">    <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">      <span class="comment">// we can run out of memory if we have too many threads</span></span><br><span class="line">      <span class="comment">// log the event and sleep for a minute and give </span></span><br><span class="line">      <span class="comment">// some thread(s) a chance to finish</span></span><br><span class="line">      LOG.warn(<span class="string">"Out of Memory in server select"</span>, e);</span><br><span class="line">      closeCurrentConnection(key, e);</span><br><span class="line">      cleanupConnections(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">60000</span>); &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> ie) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> e) &#123;</span><br><span class="line">      closeCurrentConnection(key, e);</span><br><span class="line">    &#125;</span><br><span class="line">    cleanupConnections(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  因此，服务器负载太高，内存不足时会关闭当前连接，同时对所有空闲时间超出maxIdleTime的连接进行清理，而对select操作的其他异常，关闭当前连接。此外，每次listener执行完一次连接请求后，会随机对部分连接进行清理，清理空闲时间超出<code>maxIdleTime</code>的连接。<br>  cleanupConnections详细分析见后面&lt;资源清理&gt;，传入参数为true时，强制清理，且所有连接参与清理，而传入参数为false时，当当前连接数超过<code>thresholdIdleConnections</code>(ipc.client.idlethreshold，默认4000)时进行清理，选取随机个连接参与清理。清理时，对于每一个连接，如果其空闲(rpcCount为0)时间大于<code>maxIdleTime</code>则关闭连接。大于maxIdleTime表明长时间没有收到客户端的心跳，应该关闭连接。</p>
</li>
<li>doRead<br>读取到的数据大小为-1时，关闭连接，可能情况有:<ul>
<li>读操作异常，返回-1，此时客户端连接主动关闭了，因此关闭服务器端连接；</li>
<li>读取rpcHeader时，魔数或版本号不匹配，连接关闭;</li>
<li>通过连接头和rpc头信息鉴权失败，连接关闭；</li>
</ul>
</li>
<li><p>listener的run方法<br>这里对应监听器退出时的连接清理，即对应服务器的关闭</p>
  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...<span class="comment">//主循环</span></span><br><span class="line">  LOG.info(<span class="string">"Stopping "</span> + <span class="keyword">this</span>.getName());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      acceptChannel.close();</span><br><span class="line">      selector.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    selector= <span class="keyword">null</span>;</span><br><span class="line">    acceptChannel= <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// clean up all connections</span></span><br><span class="line">    <span class="keyword">while</span> (!connectionList.isEmpty()) &#123;</span><br><span class="line">      closeConnection(connectionList.remove(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>doPurge<br>对应响应队列中存在长时间(15min)未发送出去的响应，此时应该关闭连接，这个在前面分析过了，不再分析；</p>
</li>
<li>processResponse<br>对应处理响应的过程中出现错误，如写响应过程中服务器关闭被中断，关闭连接</li>
</ul>
<hr>
<h2 id="4-_服务器资源清理">4. 服务器资源清理</h2><p>由前面分析，服务器分别可能在监听器和响应器中对连接进行清理。监听器负责清理长时间空闲(即长时间没收到心跳)的连接，而响应器负责清理响应长时间没发送出去的连接。  </p>
<h3 id="4-1_监听器清理连接">4.1 监听器清理连接</h3><p>监听器在选择操作select异常时，会关闭当前连接，而如果出现内存不足，强制对所有连接进行清理操作。此外，每次循环到达连接数到达清理阈值时，都会随机性的选择一些连接进行清理。<br>清理操作发生在<code>cleanupConnections</code>中<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">cleanupConnections</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (force || numConnections &gt; thresholdIdleConnections) &#123;<span class="comment">//强制性清理不判断连接数，否则只有连接数超过阈值(默认4000)时才进行清理</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (!force &amp;&amp; (currentTime - lastCleanupRunTime) &lt; cleanupInterval) &#123;<span class="comment">//非强制性，连接数没有超过阈值，不清理</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//强制性，选择全部连接清理</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = numConnections - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!force) &#123;<span class="comment">//非强制性，随机选择连接进行清理</span></span><br><span class="line">      start = rand.nextInt() % numConnections;</span><br><span class="line">      end = rand.nextInt() % numConnections;</span><br><span class="line">      <span class="keyword">int</span> temp;</span><br><span class="line">      <span class="keyword">if</span> (end &lt; start) &#123;</span><br><span class="line">        temp = start;</span><br><span class="line">        start = end;</span><br><span class="line">        end = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> numNuked = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= end) &#123;</span><br><span class="line">      Connection c;</span><br><span class="line">      <span class="keyword">synchronized</span> (connectionList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          c = connectionList.get(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (c.timedOut(currentTime)) &#123;<span class="comment">//如果空闲时间超过maxIdleTime，关闭连接</span></span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">          LOG.debug(getName() + <span class="string">": disconnecting client "</span> + c.getHostAddress());</span><br><span class="line">        closeConnection(c);</span><br><span class="line">        numNuked++;</span><br><span class="line">        end--;</span><br><span class="line">        c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!force &amp;&amp; numNuked == maxConnectionsToNuke) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    lastCleanupRunTime = System.currentTimeMillis();<span class="comment">//更新上次清理时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是强制性清理，则不管当前连接数都进行清理(发生在内存不足)，且清理所有的连接。而非强制性清理，只有在连接数超过阈值(默认4000)时，才进行清理，且随机选择部分连接进行清理。而对每一个待清理的连接，通过timedOut判断是否应该清理<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">timedOut</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isIdle() &amp;&amp; currentTime -  lastContact &gt; maxIdleTime)<span class="comment">//空闲，且上次和客户端通信时间到目前超过了maxIdleTime</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此如果当前连接没有rpc调用(rpcCount为0)，且从上次和客户端通信到现在超过了maxIdleTime，则应该关闭连接，表明很长时间没收到客户端的心跳。这里maxIdleTime为客户端maxIdleTime(ipc.client.connection.maxidletime)的两倍，不过客户端缺省10s，而服务器缺省1s(这样的意义何在？不知道代码是不是有问题)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">this</span>.maxIdleTime = remoteId.getMaxIdleTime();</span><br><span class="line">conf.getInt(<span class="string">"ipc.client.connection.maxidletime"</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">this</span>.maxIdleTime = <span class="number">2</span>*conf.getInt(<span class="string">"ipc.client.connection.maxidletime"</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2_响应器清理连接">4.2 响应器清理连接</h3><p>响应器也会在每次处理完一次响应后判断是否达到purge间隔(15min)，如果需要purge则对所有包含响应Call的连接通过<code>doPurge</code>进行清理，如果该连接存在从接收到调用请求到目前时间超过purge间隔(15min)还未发送出去的响应，则关闭该连接，具体的过程在前面的<code>doPurge</code>已经分析过了。</p>
<hr>
<h2 id="5-_客户端关闭">5. 客户端关闭</h2><p>客户端关闭在<code>Client.stop()</code>方法中<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">"Stopping client"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!running.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;<span class="comment">//设置running为false</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// wake up all connections,中断客户端上所有连接，被中断后连接将关闭</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connections) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connection conn : connections.values()) &#123;</span><br><span class="line">        conn.interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// wait until all connections are closed</span></span><br><span class="line">    <span class="keyword">while</span> (!connections.isEmpty()) &#123;<span class="comment">//等待所有连接关闭</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，设置running为false后，中断连接线程，使得连接线程关闭。<br>对于连接线程来说，要么处于<code>waitForWork</code>中，要么处于<code>receiveResponse</code>中。<br>waitForWork中，如果不是处于wait等待中，则running为false直接返回false，而在wait等待中时，线程中断抛出<code>InterruptedException</code>同样的从等待中返回，此时running为false，返回false。<br>receiveResponse中，等到下一次执行读操作，将会抛出<code>InterruptedException</code>作为<code>IOException</code>的子类，然后在catch中调用markClosed设置shouldCloseConnection为true，然后在下次waitForWork中将返回false。而如果receiveResponse中所有数据已经读取完，正在进行处理，则不会调用markClosed，当前receiveResponse正常返回后，下次waitForWork判断中running为false返回，对应最后一种情况<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!calls.isEmpty() &amp;&amp; !shouldCloseConnection.<span class="keyword">get</span>() &amp;&amp; running.<span class="keyword">get</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldCloseConnection.<span class="keyword">get</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (calls.isEmpty()) &#123; <span class="comment">// idle connection closed or stopped</span></span><br><span class="line">    markClosed(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// get stopped but there are still pending requests </span></span><br><span class="line">    markClosed((IOException)<span class="keyword">new</span> IOException().initCause(<span class="keyword">new</span> InterruptedException()));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这都将导致连接的关闭。  </p>
<p>因此客户端关闭时，就是关闭所有的连接。  </p>
<p>而Client.close主要由<code>stopClient</code>调用<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> stopClient(Client <span class="keyword">client</span>) &#123;</span><br><span class="line">  synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">client</span>.decCount();<span class="comment">//减少客户端rpc调用引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">client</span>.isZeroReference()) &#123;<span class="comment">//如果Client引用计数为0，从clients中移除</span></span><br><span class="line">      clients.remove(<span class="keyword">client</span>.getSocketFactory());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">client</span>.isZeroReference()) &#123;<span class="comment">//引用计数为0，关闭客户端</span></span><br><span class="line">    <span class="keyword">client</span>.stop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而因为客户端为Invoker对象所拥有，即间接的为客户端代理所拥有，关闭代理时关闭客户端。<br>stopClient主要在Invoker的close方法中调用<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isClosed) &#123;</span><br><span class="line">    isClosed = <span class="keyword">true</span>;</span><br><span class="line">    CLIENTS.stopClient(client);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而停止代理时，会调用Invoker的close方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">stopProxy</span><span class="params">(VersionedProtocol proxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proxy!=<span class="keyword">null</span>) &#123;</span><br><span class="line">      ((Invoker)Proxy.getInvocationHandler(proxy)).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，总的来说，一个客户端可能被多个代理使用，每一个代理增加客户端的引用计数refCount，当代理关闭时，相应的减少客户端的引用计数，如果代理关闭时客户端的引用计数为0，则关闭客户端。  </p>
<p>客户端关闭时，会中断所有的连接，等待所有连接关闭。</p>
<hr>
<h2 id="6-_服务器关闭">6. 服务器关闭</h2><p>服务器关闭通过服务器的stop方法完成<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">"Stopping server on "</span> + port);</span><br><span class="line">    running = <span class="keyword">false</span>;<span class="comment">//设置running为false</span></span><br><span class="line">    <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;<span class="comment">//中断所有处理器</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; handlerCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">          handlers[i].interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listener.interrupt();<span class="comment">//中断监听器</span></span><br><span class="line">    listener.doStop();<span class="comment">//停止监听器</span></span><br><span class="line">    responder.interrupt();<span class="comment">//中断响应器</span></span><br><span class="line">    notifyAll();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rpcMetrics != <span class="keyword">null</span>) &#123;<span class="comment">//关闭统计度量</span></span><br><span class="line">      <span class="keyword">this</span>.rpcMetrics.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此将running置为false，分别中断处理器，监听器和响应器，监听器还要调用doStop方法停止，三种线程每次循环都会判断服务器是否运行，没有运行则退出主循环。</p>
<ul>
<li>处理器对中断的响应<ul>
<li>等待从callQueue阻塞队列中获取一个元素时，抛出InterruptedException，退出处理器主程序；</li>
<li>处理器线程执行<code>processResponse</code>过程中，阻塞在<code>channelWrite</code>写响应时，抛出IOException，退出处理器主程序；</li>
</ul>
</li>
<li>监听器中对中断的响应<br>在select上阻塞时，中断唤醒，然后running为false，退出主循环，执行接下来的<code>connectionList</code>的清理工作，清理完后退出监听器主程序</li>
<li>响应器对中断的响应<ul>
<li>waitPending中等待通道注册，抛出InterruptedException，退出响应器主程序；</li>
<li>在select操作上阻塞，中断唤醒，执行完接下来的操作，退出响应器主程序；</li>
<li>响应器执行<code>doAsyncWrite</code>过程中，阻塞在<code>channelWrite</code>写响应时，抛出异常，停止写响应。因为在响应器中会对每一个可写的通道执行<code>doAsyncWrite</code>，则此时会对后续每一个要写响应的通道终止写操作，执行后面的purge操作后，退出响应器主程序；</li>
</ul>
</li>
</ul>
<p>监听器执行doStop关闭<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">synchronized <span class="literal">void</span> doStop() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">select</span><span class="subst">or</span> != <span class="built_in">null</span>) &#123;<span class="comment">//选择器不为null</span></span><br><span class="line">    <span class="keyword">select</span><span class="subst">or</span><span class="built_in">.</span>wakeup();<span class="comment">//唤醒可能阻塞在select上的操作</span></span><br><span class="line">    <span class="keyword">Thread</span><span class="built_in">.</span><span class="keyword">yield</span>();<span class="comment">//等待监听器线程执行完</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (acceptChannel != <span class="built_in">null</span>) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      acceptChannel<span class="built_in">.</span>socket()<span class="built_in">.</span>close();<span class="comment">//关闭socket</span></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      <span class="keyword">LOG</span><span class="built_in">.</span>info(getName() + <span class="string">":Exception in closing listener socket. "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  readPool<span class="built_in">.</span>shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此服务器关闭时，会关闭处理器，监听器，响应器。而在关闭监听器时，还会关闭服务器下的所有连接<code>connectionList</code>(关闭对应的通道socket)，关闭服务器端监听的Socket，关闭线程池。</p>
<hr>
<h2 id="7-_整帧数据的读写">7. 整帧数据的读写</h2><p>我们这里将每个调用的数据以及响应视为一帧数据。<br>那么客户端如何保证是一帧一帧数据的发送到服务器，而不会产生一帧数据中夹带另外一帧数据的，服务器怎么保证接收到完整一帧数据，发送响应时如何保证在连接上一整帧数据的发送，客户端接收响应时如何保证接收一整帧数据的呢。  </p>
<p>客户端通过获取连接上的输出流out对象来同步的<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">synchronized (this.<span class="type">out</span>) &#123;</span><br><span class="line">  d = new DataOutputBuffer();</span><br><span class="line">  d.writeInt(<span class="keyword">call</span>.id);</span><br><span class="line">  <span class="keyword">call</span>.param.<span class="built_in">write</span>(d);</span><br><span class="line">  byte[] <span class="type">data</span> = d.getData();</span><br><span class="line">  <span class="built_in">int</span> dataLength = d.getLength();</span><br><span class="line">  <span class="type">out</span>.writeInt(dataLength);      //first put the <span class="type">data</span> length</span><br><span class="line">  <span class="type">out</span>.<span class="built_in">write</span>(<span class="type">data</span>, <span class="number">0</span>, dataLength);//<span class="built_in">write</span> the <span class="type">data</span></span><br><span class="line">  <span class="type">out</span>.<span class="keyword">flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上为sendParam中发送一帧数据的代码段，可见每次都只能发送完一帧数据后，释放out对象然后下一帧获取，继续发送，因此即使在多线程中，一个连接上也只能一整帧一整帧的数据发送。  </p>
<p>TCP Socket保证了服务器端的按序接收，这样在服务器端便是一整帧的数据接收。<br>帧长度保存在4个字节的dataLengthBuffer缓冲区中，然后根据此值分配data缓冲区，读取一整帧数据到data缓冲区中。<br>缓冲区没填满时直接返回接收到的字节数，更新通信时间lastActivity，当data缓冲区填满后，接收了完整的一帧数据，进行处理。<br>具体过程前面已经分析过了，见<code>readAndProcess</code>。<br>因为服务器接收请求是在Reader线程中，一个Reader线程处理多个连接，因此不存在在多个线程上从一个连接通道上接收数据，导致一帧数据请求被分别被多个线程接收到部分数据的情况，无需同步就能在Reader线程上接收到完整的一帧请求数据。</p>
<p>然后，服务器调用完成后，发送响应。先发4个字节的id，然后是1个字节的状态(0,1,或-1)。<br>正常返回时通过ObjectWritable封装返回值序列化发送到客户端，ObjectWritable的序列化见<a href="../序列化">序列化</a>。<br>存在异常时，序列化两个字符串(分别为异常类和异常信息)，而字符串的序列化其实是先发送字符串字节长度，然后是字符串编码字节结果。<br>服务器发送响应时，同步连接上的响应队列responseQueue，然后发送一帧响应数据。发送响应时，可能多个handler线程对一个连接上的Call处理完毕，需要添加到responseQueue中，而这时如果有一个handler线程正在发送响应的话，其他handler要等待响应发送完成才能添加到响应队列。同样的，当handler需要添加Call到响应队列中，而这时responder在发送该连接上的响应时，handler线程需要等待响应发送完，获得responseQueue对象管理权。<br>这样保证了发送响应过程中，响应队列安全写操作以及一帧数据的完整发送。  </p>
<p>在客户端接收响应时，因为连接是一个线程，就算多个线程在该连接上远程调用，这些线程调用完后阻塞，是通过这一个连接线程通知响应到达的，只能一帧一帧数据接收，接受完后通知调用线程，因此无需同步便能得到完整的一帧数据。</p>
<hr>
<h2 id="8-_疑问">8. 疑问</h2><ul>
<li>客户端的输入流通过<code>socket.getInputStream</code>或创建SocketInputStream创建底层输入流，然后封装PingInputStream以及相应的流。<br>输出流通过<code>socket.getOutputStream</code>或创建SocketOutputStream创建底层输出流，然后封装相应的流。这样读写操作便不会对客户端关闭时连接的中断进行响应，也就是说读操作要等待读超时(rpcTimeout大于0)或ping异常(服务器连接关闭)，而写操作要等待写超时才会关闭该连接，关闭客户端是否会有很大延迟？</li>
</ul>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Common/" rel="tag">#Common</a>
          
            <a href="/tags/Hadoop-1-2-1/" rel="tag">#Hadoop-1.2.1</a>
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
            <a href="/tags/RPC/" rel="tag">#RPC</a>
          
            <a href="/tags/RPC源码阅读/" rel="tag">#RPC源码阅读</a>
          
            <a href="/tags/源码阅读/" rel="tag">#源码阅读</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/RPC源码分析上篇/" rel="next" title="RPC源码阅读---源码分析上篇">
                <i class="fa fa-chevron-left"></i> RPC源码阅读---源码分析上篇
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Socket选项/" rel="prev" title="TCP Socket选项">
                TCP Socket选项 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


        </div>

        


        
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="RPC源码分析下篇/"
           data-title="RPC源码阅读---源码分析下篇" data-url="http://xiao-yun.github.io/RPC源码分析下篇/">
      </div>
    
  </div>


      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/hero.jpg" alt="xiaoyun" itemprop="image"/>
          <p class="site-author-name" itemprop="name">xiaoyun</p>
        </div>
        <p class="site-description motion-element" itemprop="description">学习笔记，网上资源摘要等</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiao-yun" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-_方法调用请求和响应"><span class="nav-number">1.</span> <span class="nav-text">1. 方法调用请求和响应</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1_客户端调用请求"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 客户端调用请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2_服务器端调用请求的响应"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 服务器端调用请求的响应</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1_监听器处理"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 监听器处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2_处理器处理"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 处理器处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-1_主程序"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1.2.2.1 主程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-2_call"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">1.2.2.2 call</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-3_setupResponse"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">1.2.2.3 setupResponse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-4_doRespond"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">1.2.2.4 doRespond</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-5_processResponse"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">1.2.2.5 processResponse</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3_响应器处理"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 响应器处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-1_等待通道注册"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">1.2.3.1 等待通道注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-2_doAsyncWrite"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">1.2.3.2 doAsyncWrite</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-3_doPurge"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">1.2.3.3 doPurge</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-_客户端接收响应"><span class="nav-number">2.</span> <span class="nav-text">2. 客户端接收响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-_连接的关闭"><span class="nav-number">3.</span> <span class="nav-text">3. 连接的关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1_客户端连接关闭"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 客户端连接关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2_服务器连接的关闭"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 服务器连接的关闭</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-_服务器资源清理"><span class="nav-number">4.</span> <span class="nav-text">4. 服务器资源清理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1_监听器清理连接"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 监听器清理连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2_响应器清理连接"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 响应器清理连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-_客户端关闭"><span class="nav-number">5.</span> <span class="nav-text">5. 客户端关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-_服务器关闭"><span class="nav-number">6.</span> <span class="nav-text">6. 服务器关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-_整帧数据的读写"><span class="nav-number">7.</span> <span class="nav-text">7. 整帧数据的读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-_疑问"><span class="nav-number">8.</span> <span class="nav-text">8. 疑问</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoyun</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xiaoyuncom"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    motionMiddleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');
      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    };
  });
</script>



  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
