<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Common,Hadoop-1.2.1,RPC," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Hadoop版本:Hadoop-1.2.1参考：《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》,后文简称技术内幕RPC中用到的通道和选择器另见通道和选择器，缓冲区另见缓冲区,以及序列化(主要是ObjectWritable)另见序列化下文所说的[概述]为上篇RPC源码分析—概述本文不涉及SIMPLE，DIGEST，KERBEROS三种鉴权方式的鉴权过程分析">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC源码阅读---源码分析上篇">
<meta property="og:url" content="http://xiao-yun.github.io/RPC源码分析上篇/index.html">
<meta property="og:site_name" content="xiaoyun">
<meta property="og:description" content="Hadoop版本:Hadoop-1.2.1参考：《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》,后文简称技术内幕RPC中用到的通道和选择器另见通道和选择器，缓冲区另见缓冲区,以及序列化(主要是ObjectWritable)另见序列化下文所说的[概述]为上篇RPC源码分析—概述本文不涉及SIMPLE，DIGEST，KERBEROS三种鉴权方式的鉴权过程分析">
<meta property="og:updated_time" content="2015-12-26T09:16:07.761Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RPC源码阅读---源码分析上篇">
<meta name="twitter:description" content="Hadoop版本:Hadoop-1.2.1参考：《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》,后文简称技术内幕RPC中用到的通道和选择器另见通道和选择器，缓冲区另见缓冲区,以及序列化(主要是ObjectWritable)另见序列化下文所说的[概述]为上篇RPC源码分析—概述本文不涉及SIMPLE，DIGEST，KERBEROS三种鉴权方式的鉴权过程分析">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide',
    motion: true
  };
</script>

  <title> RPC源码阅读---源码分析上篇 | xiaoyun </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?caeb4129c91d1e6fb3d562d35fedef0d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">xiaoyun</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                RPC源码阅读---源码分析上篇
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-26T17:16:07+08:00" content="2015-12-26">
              2015-12-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop/Hadoop-1-2-1/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop-1.2.1</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop/Hadoop-1-2-1/Common/" itemprop="url" rel="index">
                    <span itemprop="name">Common</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop/Hadoop-1-2-1/Common/RPC/" itemprop="url" rel="index">
                    <span itemprop="name">RPC</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/Hadoop/Hadoop-1-2-1/Common/RPC/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/RPC源码分析上篇/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="RPC源码分析上篇/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>Hadoop版本:<a href="https://archive.apache.org/dist/hadoop/core/hadoop-1.2.1/" target="_blank" rel="external">Hadoop-1.2.1</a><br>参考：《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》,后文简称技术内幕<br>RPC中用到的通道和选择器另见<a href="./通道和选择器">通道和选择器</a>，缓冲区另见<a href="./缓冲区">缓冲区</a>,以及序列化(主要是ObjectWritable)另见<a href="./序列化">序列化</a><br>下文所说的[概述]为上篇<a href="./RPC源码分析---概述">RPC源码分析—概述</a><br>本文不涉及SIMPLE，DIGEST，KERBEROS三种鉴权方式的鉴权过程分析</p>
<hr>
<p>本文所属<code>RPC源码分析</code>，按照调用请求的步骤对源码进行分析，限于篇幅分为上下两篇。  </p>
<p>上篇分析了”客户端代理创建”，”服务器创建启动”，”客户端服务器连接建立”，”客户端头数据发送”，”服务器对头数据验证，鉴权”，至此连接已经建立验证，<br>可以发送正常的调用请求了。本文即为上篇。  </p>
<p>而下篇分析了”客户端调用请求”，”服务器对调用请求的处理响应”，”客户端接收响应”，”客户端服务器连接的关闭”，”客户端关闭”，”服务器关闭”等过程，<br>下篇另见<a href="./RPC源码分析下篇">RPC源码分析下篇</a>。  </p>
<hr>
<h2 id="客户端代理创建">客户端代理创建</h2><p>由<code>RPC.getProxy</code>获取客户端代理，由[概述]分析知一个代理处理用户到具体服务器的具体协议对应的连接，同时连接属于一个Client，而Client一般由<br>SocketFactory决定，不同SocketFactory对应不同Client。因此getProxy需指定包括<code>SocketFactory</code>，<code>用户</code>，<code>服务器地址</code>，<code>协议</code>这4个信息，<br>另外还需指定连接读操作超时时间。<br>对应getProxy重要的5个信息，最少需给定<code>服务器地址</code>和使用的<code>协议</code>，其他的都可以默认。<code>SocketFactory</code>默认为默认SocketFactory，用户默认为<br>当前用户，读操作超时时间默认为0，此时会设置为pingInterval(见[概述])。</p>
<p>getProxy的重载:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定协议protocol，地址addr。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">VersionedProtocol <span class="title">getProxy</span><span class="params">(Class&lt;? <span class="keyword">extends</span> VersionedProtocol&gt; protocol,</span><br><span class="line">  <span class="keyword">long</span> clientVersion, InetSocketAddress addr, Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProxy(protocol, clientVersion, addr, conf, NetUtils.getDefaultSocketFactory(conf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定协议protocol，地址addr，SockeFactory factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">VersionedProtocol <span class="title">getProxy</span><span class="params">(Class&lt;? <span class="keyword">extends</span> VersionedProtocol&gt; protocol,</span><br><span class="line">    <span class="keyword">long</span> clientVersion, InetSocketAddress addr, Configuration conf,SocketFactory factory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getProxy</span><span class="params">(protocol, clientVersion, addr, ugi, conf, factory, <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定协议protocol，地址addr，SocketFactory factory，超时rpcTimeout</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">VersionedProtocol <span class="title">getProxy</span><span class="params">(Class&lt;? <span class="keyword">extends</span> VersionedProtocol&gt; protocol,</span><br><span class="line">    <span class="keyword">long</span> clientVersion, InetSocketAddress addr, Configuration conf,</span><br><span class="line">    SocketFactory factory, <span class="keyword">int</span> rpcTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getProxy</span><span class="params">(protocol, clientVersion, addr, ugi, conf, factory, rpcTimeout)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定协议protocol，地址addr，用户ticket，SocketFactory factory，超时rpcTimeout</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">VersionedProtocol <span class="title">getProxy</span><span class="params">(Class&lt;? <span class="keyword">extends</span> VersionedProtocol&gt; protocol,</span><br><span class="line">    <span class="keyword">long</span> clientVersion, InetSocketAddress addr, UserGroupInformation ticket,</span><br><span class="line">    Configuration conf, SocketFactory factory, <span class="keyword">int</span> rpcTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getProxy</span><span class="params">(protocol, clientVersion, addr, ticket, conf, factory,rpcTimeout, <span class="keyword">null</span>, <span class="keyword">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，最终会使用最多参数的<code>getProxy</code>创建代理对象:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> VersionedProtocol getProxy(<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> VersionedProtocol&gt; protocol,</span><br><span class="line">      <span class="keyword">long</span> clientVersion, InetSocketAddress addr, UserGroupInformation ticket,</span><br><span class="line">      Configuration conf, SocketFactory factory, <span class="keyword">int</span> rpcTimeout,</span><br><span class="line">      RetryPolicy connectionRetryPolicy, <span class="keyword">boolean</span> checkVersion) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (UserGroupInformation.isSecurityEnabled()) &#123;</span><br><span class="line">      SaslRpcServer.init(conf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由protocol,addr,ticket,factory,rpcTimeout等信息创建调用处理器对象Invoker，其中connectionRetryPolicy缺省为重试10次，每次间隔1s</span></span><br><span class="line">    <span class="keyword">final</span> Invoker invoker = <span class="keyword">new</span> Invoker(protocol, addr, ticket, conf, factory, rpcTimeout, connectionRetryPolicy);</span><br><span class="line">    <span class="comment">//创建动态代理，代理的调用处理器为上面创建的invoker</span></span><br><span class="line">    VersionedProtocol proxy = (VersionedProtocol)Proxy.newProxyInstance( protocol.getClassLoader(), <span class="keyword">new</span> <span class="keyword">Class</span>[]&#123;protocol&#125;, invoker);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (checkVersion) &#123;<span class="comment">//默认情况下需要检查客户端和服务器协议的版本</span></span><br><span class="line">      checkVersion(protocol, clientVersion, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，创建代理主要就是通过传入的参数创建对应的调用处理器对象Invoker，然后通过<a href="./Java动态代理">Java动态代理</a>创建动态代理，创建代理后，<br>默认情况下需要检查客户端和服务器协议的版本号，不匹配的话抛出<code>VersionMismatch</code>异常。因此，创建的代理核心信息保存在调用处理器invoker中。<br>看一下Invoker的构造:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Invoker</span><span class="params">(Class&lt;? <span class="keyword">extends</span> VersionedProtocol&gt; protocol,</span><br><span class="line">    InetSocketAddress address, UserGroupInformation ticket, Configuration conf,</span><br><span class="line">    SocketFactory factory,<span class="keyword">int</span> rpcTimeout, RetryPolicy connectionRetryPolicy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.remoteId = Client.ConnectionId.getConnectionId(address, protocol, ticket, rpcTimeout, connectionRetryPolicy, conf);</span><br><span class="line">    <span class="keyword">this</span>.client = CLIENTS.getClient(conf, factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，就是通过传入的用户，服务器地址，协议，超时时间等信息构建Invoker负责处理连接的标识<code>ConnectionId</code>，即确定了该Invoker负责处理的连接。<br>而用SocketFactory在缓存中查找所属客户端，若存在现有使用该factory的客户端直接使用，只是增加其引用计数<code>refCount</code>,否则构建一个Client对象，<br><code>valueClass</code>初始化为<code>ObjectWritable</code>。<br>这些成员具体含义另见[概述]。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> synchronized Client getClient(Configuration conf,</span><br><span class="line">    SocketFactory factory) &#123;</span><br><span class="line">    Client <span class="keyword">client</span> = clients.get(factory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">client</span> == <span class="keyword">null</span>) &#123;<span class="comment">//不存在，构建Client对象，valueClass为ObjectClass，并放入缓存</span></span><br><span class="line">        <span class="keyword">client</span> = <span class="keyword">new</span> Client(ObjectWritable.class, conf, factory);</span><br><span class="line">        clients.put(factory, <span class="keyword">client</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">client</span>.incCount();<span class="comment">//存在的话，client新增了一个Connection，增加引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">client</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，客户端的代理构建完成了，其实主要是构建了代理关联的调用处理器中的<code>connectionId</code>(对应一个Connection)，以及<code>client</code>(将代理处理的连接<br>注册到相应客户端)。  </p>
<hr>
<h2 id="服务器创建">服务器创建</h2><p>创建服务器对象，通过<code>RPC.getServer</code>完成，至少指定服务器绑定的地址和端口，以及实现协议的实例对象，看方法重载:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定实现协议的实例对象instance，要绑定的地址bindAddress和端口port</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Server <span class="title">getServer</span><span class="params">(<span class="keyword">final</span> Object instance, <span class="keyword">final</span> String bindAddress, <span class="keyword">final</span> <span class="keyword">int</span> port, Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getServer</span><span class="params">(instance, bindAddress, port, <span class="number">1</span>, <span class="keyword">false</span>, conf)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定instance，bindAddress，port的基础上，指定处理器线程数目(缺省1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Server <span class="title">getServer</span><span class="params">(<span class="keyword">final</span> Object instance, <span class="keyword">final</span> String bindAddress, <span class="keyword">final</span> <span class="keyword">int</span> port,</span><br><span class="line">                             <span class="keyword">final</span> <span class="keyword">int</span> numHandlers, <span class="keyword">final</span> <span class="keyword">boolean</span> verbose, Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getServer</span><span class="params">(instance, bindAddress, port, numHandlers, verbose, conf, <span class="keyword">null</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上有基础上，再指定安全管理器secretManager(缺省为null)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Server <span class="title">getServer</span><span class="params">(<span class="keyword">final</span> Object instance, <span class="keyword">final</span> String bindAddress, <span class="keyword">final</span> <span class="keyword">int</span> port,</span><br><span class="line">                             <span class="keyword">final</span> <span class="keyword">int</span> numHandlers, <span class="keyword">final</span> <span class="keyword">boolean</span> verbose, Configuration conf,</span><br><span class="line">                             SecretManager&lt;? <span class="keyword">extends</span> TokenIdentifier&gt; secretManager)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Server(instance, conf, bindAddress, port, numHandlers, verbose, secretManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，最终通过<code>RPC.Server</code>的构造函数构建服务器对象。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(Object instance, Configuration conf, String bindAddress,  <span class="keyword">int</span> port, <span class="keyword">int</span> numHandlers,</span><br><span class="line">                <span class="keyword">boolean</span> verbose, SecretManager&lt;? <span class="keyword">extends</span> TokenIdentifier&gt; secretManager)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(bindAddress, port, Invocation.class, numHandlers, conf,classNameBase(instance.getClass().getName()), secretManager);</span><br><span class="line">  <span class="keyword">this</span>.instance = instance;</span><br><span class="line">  <span class="keyword">this</span>.verbose = verbose;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用父类<code>org.apache.hadoop.ipc.Server</code>的构造函数，然后初始化实现协议的实例对象instance。父类构造函数如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Server</span><span class="params">(String bindAddress, <span class="keyword">int</span> port, Class&lt;? extends Writable&gt; paramClass, <span class="keyword">int</span> handlerCount, </span><br><span class="line">                  Configuration conf, String serverName, SecretManager&lt;? extends TokenIdentifier&gt; secretManager)</span> </span><br><span class="line">    throws IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bindAddress = bindAddress;<span class="comment">//绑定地址</span></span><br><span class="line">    <span class="keyword">this</span>.conf = conf;</span><br><span class="line">    <span class="keyword">this</span>.port = port;<span class="comment">//绑定端口</span></span><br><span class="line">    <span class="keyword">this</span>.paramClass = paramClass;<span class="comment">//客户端传过来的包含调用方法参数等信息的参数类，为Invocation</span></span><br><span class="line">    <span class="keyword">this</span>.handlerCount = handlerCount;<span class="comment">//处理器线程数目，默认1</span></span><br><span class="line">    <span class="keyword">this</span>.socketSendBufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//待处理Call队列callQueue中最大的待处理Call数，默认100</span></span><br><span class="line">    <span class="keyword">this</span>.maxQueueSize = handlerCount * conf.getInt(IPC_SERVER_HANDLER_QUEUE_SIZE_KEY,IPC_SERVER_HANDLER_QUEUE_SIZE_DEFAULT);</span><br><span class="line">    <span class="comment">//响应缓冲最大大小，1MB</span></span><br><span class="line">    <span class="keyword">this</span>.maxRespSize = conf.getInt(IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY, IPC_SERVER_RPC_MAX_RESPONSE_SIZE_DEFAULT);</span><br><span class="line">    <span class="comment">//监听器listener中Reader线程数目，默认1</span></span><br><span class="line">    <span class="keyword">this</span>.readThreads = conf.getInt(IPC_SERVER_RPC_READ_THREADS_KEY,IPC_SERVER_RPC_READ_THREADS_DEFAULT);</span><br><span class="line">    <span class="keyword">this</span>.callQueue  = <span class="keyword">new</span> LinkedBlockingQueue&lt;Call&gt;(maxQueueSize);<span class="comment">//构造callQueue </span></span><br><span class="line">    <span class="keyword">this</span>.maxIdleTime = <span class="number">2</span>*conf.getInt(<span class="string">"ipc.client.connection.maxidletime"</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">this</span>.maxConnectionsToNuke = conf.getInt(<span class="string">"ipc.client.kill.max"</span>, <span class="number">10</span>);<span class="comment">//清理空闲连接时一次最多清理的个数</span></span><br><span class="line">    <span class="comment">//服务器端连接超过此值应该执行清理(连接数过多，一个连接为一个线程，资源消耗大)</span></span><br><span class="line">    <span class="keyword">this</span>.thresholdIdleConnections = conf.getInt(<span class="string">"ipc.client.idlethreshold"</span>, <span class="number">4000</span>);</span><br><span class="line">    <span class="keyword">this</span>.secretManager = (SecretManager&lt;TokenIdentifier&gt;) secretManager;</span><br><span class="line">    <span class="keyword">this</span>.authorize = conf.getBoolean(HADOOP_SECURITY_AUTHORIZATION, <span class="literal">false</span>);<span class="comment">//是否鉴权</span></span><br><span class="line">    <span class="keyword">this</span>.isSecurityEnabled = UserGroupInformation.isSecurityEnabled();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start the listener here and let it bind to the port</span></span><br><span class="line">    listener = <span class="keyword">new</span> Listener();<span class="comment">//构建监听器</span></span><br><span class="line">    <span class="keyword">this</span>.port = listener.getAddress().getPort();    </span><br><span class="line">    <span class="keyword">this</span>.rpcMetrics = RpcInstrumentation.create(serverName, <span class="keyword">this</span>.port);</span><br><span class="line">    <span class="keyword">this</span>.tcpNoDelay = conf.getBoolean(<span class="string">"ipc.server.tcpnodelay"</span>, <span class="literal">false</span>);<span class="comment">//是否开启Nagel算法，默认false开启</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the responder here</span></span><br><span class="line">    responder = <span class="keyword">new</span> Responder();<span class="comment">//响应器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isSecurityEnabled) &#123;</span><br><span class="line">      SaslRpcServer.init(conf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化相应成员后，构建监听器<code>listener</code>和响应器<code>responder</code>，而对应的多个处理器在<code>start</code>方法中创建。  </p>
<p>构建监听器时，会打开一个选择器，然后将ServerSocketChannel注册到选择器上，注册Accept操作，由该选择器负责处理到来的连接请求。<br>同时创建<code>readThreads</code>个Reader线程并启动，每一个Reader线程中都有一个Selector。<br>由listener中的Selector处理Accept的连接请求，会创建SocketChannel对象，然后从所有的Reader线程中选择下一个Reader线程，将accept的SocketChannel<br>注册在选择的Reader线程的Selector中，注册读操作，这样便由该Reader线程负责该连接到来的数据请求。  </p>
<h3 id="监听器构造">监听器构造</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Listener() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  address = <span class="keyword">new</span> InetSocketAddress(bindAddress, port);</span><br><span class="line">  <span class="comment">// Create a new server socket and set to non blocking mode</span></span><br><span class="line">  acceptChannel = ServerSocketChannel.<span class="built_in">open</span>();<span class="comment">//打开服务器端唯一的ServerSocketChannel</span></span><br><span class="line">  acceptChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//配置成非阻塞模式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bind the server socket to the local host and port</span></span><br><span class="line">  bind(acceptChannel.socket(), address, backlogLength);<span class="comment">//绑定到本地地址端口</span></span><br><span class="line">  port = acceptChannel.socket().getLocalPort(); <span class="comment">//Could be an ephemeral port</span></span><br><span class="line">  <span class="comment">// create a selector;</span></span><br><span class="line">  selector= Selector.<span class="built_in">open</span>();<span class="comment">//打开选择器，该选择器用于注册accept操作</span></span><br><span class="line">  readers = <span class="keyword">new</span> Reader[readThreads];<span class="comment">//Reader线程</span></span><br><span class="line">  readPool = Executors.newFixedThreadPool(readThreads);<span class="comment">//固定大小线程池，用于创建Reader线程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; readThreads; i++) &#123;</span><br><span class="line">    Selector readSelector = Selector.<span class="built_in">open</span>();<span class="comment">//每个Reader线程对应一个Selector，用于注册accept返回的SocketChannel上的read操作</span></span><br><span class="line">    Reader reader = <span class="keyword">new</span> Reader(readSelector);</span><br><span class="line">    readers[i] = reader;</span><br><span class="line">    readPool.execute(reader);<span class="comment">//启动线程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register accepts on the server socket with the selector.</span></span><br><span class="line">  acceptChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">//ServerSocketChannel注册Accept操作</span></span><br><span class="line">  <span class="keyword">this</span>.setName(<span class="string">"IPC Server listener on "</span> + port);</span><br><span class="line">  <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应器构建">响应器构建</h3><p>响应器的创建比较简单，打开用于为写操作注册的Selector<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Responder() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">this</span>.setName(<span class="string">"IPC Server Responder"</span>);</span><br><span class="line">    <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    writeSelector = Selector.<span class="built_in">open</span>(); <span class="comment">// create a selector</span></span><br><span class="line">    pending = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="服务器启动">服务器启动</h2><p>服务器启动在<code>Server</code>的<code>start</code>方法中，一般通过<code>RPC.getServer</code>创建服务器后，调用服务器的start方法启动服务器<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    responder.start();<span class="comment">//启动响应器</span></span><br><span class="line">    listener.start();<span class="comment">//启动监听器</span></span><br><span class="line">    handlers = <span class="keyword">new</span> Handler[handlerCount];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; handlerCount; i++) &#123;</span><br><span class="line">      handlers[i] = <span class="keyword">new</span> Handler(i);<span class="comment">//创建处理器</span></span><br><span class="line">      handlers[i].start();<span class="comment">//启动处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分别启动响应器，监听器，创建对应数量的处理器并启动。处理器没有相应的成员属性，只是简单的设置了处理器线程名字以及将其设为后台线程<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">int</span> instanceNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.setName(<span class="string">"IPC Server handler "</span>+ instanceNumber + <span class="string">" on "</span> + port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="代理方法调用">代理方法调用</h2><p>通过getProxy创建代理对象后，如果在代理对象上调用协议的方法，则像<a href="./Java动态代理">Java动态代理</a>一样，会将该调用转发给其调用处理器Invoker<br>的invoke方法:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">Object</span> invoke(<span class="type">Object</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args) throws <span class="type">Throwable</span> &#123;</span><br><span class="line">      ...//日志相关</span><br><span class="line">      <span class="type">ObjectWritable</span> value = (<span class="type">ObjectWritable</span>)client.call(new <span class="type">Invocation</span>(<span class="keyword">method</span>, args), remoteId);</span><br><span class="line">      ...//日志相关</span><br><span class="line">      <span class="keyword">return</span> value.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，将调用的方法和参数封装成Invocation对象，该对象正是服务器的<code>paramClass</code>即接受的参数类。对应的在客户端会将包含方法和参数信息的Invocation<br>序列化发送到服务器，而服务器会创建Invocation对象，反序列化到来的数据，便接收到调用请求。<br>封装成Invocation对象后，通过Invoker所属的Client，调用<code>call</code>方法执行远程过程调用，该调用对应的连接标识为Invoker所属的<code>remoteId</code>。<br>调用的返回值类型为<code>ObjectWritable</code>，在Client构建时可见初始化<code>valueClass</code>为<code>ObjectWritable</code>。因为对应在服务器端发送给客户端的相应是通过<br>ObjectWritable序列化的，因此客户端这边有响应可接收时，通过构造<code>ObjectWritable</code>对象反序列化即为返回值数据。  </p>
<p>Client的call方法中，继续将方法和参数信息对象Invocation封装成一个Call对象，对应客户端的一次远程调用(另见[概述])。然后获取到服务器端的连接，<br>若连接还未建立，则需建立到服务器端的连接，发送<code>rpcHeader</code>和<code>ConnectionHeader</code>，否则直接从缓冲区中获取存在的连接。获取连接后将Invocation<br>对象信息反序列化到服务器端，休眠等待。等待的过程中由所属的Connection线程读取服务器到来的响应，读取到响应(成功或失败)时，唤醒该等待线程，<br>完成远程过程调用。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Writable <span class="keyword">call</span>(Writable param, ConnectionId remoteId) <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">    <span class="keyword">Call</span> <span class="keyword">call</span> = <span class="keyword">new</span> <span class="keyword">Call</span>(param);<span class="comment">//封装成Call对象，对应为客户端的一个远程过程调用</span></span><br><span class="line">    Connection connection = getConnection(remoteId, <span class="keyword">call</span>);<span class="comment">//获取连接，若缓冲区中没有则需创建并发送rpcHeader和ConnectionHeader到服务器</span></span><br><span class="line">    connection.sendParam(<span class="keyword">call</span>);                 <span class="comment">// send the parameter，发送调用的方法和参数信息</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">call</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">call</span>.done) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">call</span>.wait();                           <span class="comment">// wait for the result，休眠等待调用完成，由Connection线程读取响应并唤醒该等待的线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">          <span class="comment">// save the fact that we were interrupted</span></span><br><span class="line">          interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">        <span class="comment">// set the interrupt flag now that we are done waiting</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">call</span>.error != <span class="keyword">null</span>) &#123;<span class="comment">//远程调用中出现异常，直接抛出给上层，对应为协议方法捕获，就像本地调用一样</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">call</span>.error <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">          <span class="keyword">call</span>.error.fillInStackTrace();</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">call</span>.error;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// local exception</span></span><br><span class="line">          <span class="comment">// use the connection because it will reflect an ip change, unlike</span></span><br><span class="line">          <span class="comment">// the remoteId</span></span><br><span class="line">          <span class="keyword">throw</span> wrapException(connection.getRemoteAddress(), <span class="keyword">call</span>.error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常返回，获取值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">call</span>.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="建立连接">建立连接</h2><h3 id="客户端">客户端</h3><p>如上，客户端建立连接对应在<code>getConnection</code>方法中获取一个连接，若连接不在客户端维护的缓冲区<code>connections</code>中，则需创建连接<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection getConnection(ConnectionId remoteId, <span class="keyword">Call</span> <span class="keyword">call</span>) <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!running.get()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"The client is stopped"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Connection connection;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (connections) &#123;</span><br><span class="line">        connection = connections.get(remoteId);</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;<span class="comment">//connections中不存在</span></span><br><span class="line">          connection = <span class="keyword">new</span> Connection(remoteId);<span class="comment">//创建新的连接对象</span></span><br><span class="line">          connections.put(remoteId, connection);<span class="comment">//放入缓存中</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!connection.addCall(<span class="keyword">call</span>));<span class="comment">//获取的连接中添加Call对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//we don't invoke the method below inside "synchronized (connections)"</span></span><br><span class="line">    <span class="comment">//block above. The reason for that is if the server happens to be slow,</span></span><br><span class="line">    <span class="comment">//it will take longer to establish a connection and that will slow the</span></span><br><span class="line">    <span class="comment">//entire system down.</span></span><br><span class="line">    connection.setupIOstreams();<span class="comment">//如果还没建立到服务器端的连接，需连接到服务器，并发送rpcHeader和ConnectionHeader</span></span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，不存在连接，通过Connection构造方法构造新的连接对象，然后<code>addCall</code>添加到有效的连接中，最终通过<code>setupIOstreams</code>建立连接并发送头部<br>数据，开启连接线程，接收响应。  </p>
<h4 id="Connection构造">Connection构造</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connection</span><span class="params">(ConnectionId remoteId)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.remoteId = remoteId;</span><br><span class="line">    <span class="keyword">this</span>.server = remoteId.getAddress();<span class="comment">//服务器地址</span></span><br><span class="line">    <span class="keyword">if</span> (server.isUnresolved()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnknownHostException(<span class="string">"unknown host: "</span> + remoteId.getAddress().getHostName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxIdleTime = remoteId.getMaxIdleTime();<span class="comment">//连接的最大空闲时间ipc.client.connection.maxidletime，默认10s</span></span><br><span class="line">    <span class="keyword">this</span>.connectionRetryPolicy = remoteId.connectionRetryPolicy;<span class="comment">//连接重试策略，默认重试10次，每次间隔1s</span></span><br><span class="line">    <span class="keyword">this</span>.tcpNoDelay = remoteId.getTcpNoDelay();<span class="comment">//Nagle算法，ipc.client.tcpnodelay，默认为false即默认开启Nagel算法</span></span><br><span class="line">    <span class="keyword">this</span>.pingInterval = remoteId.getPingInterval();<span class="comment">//ping周期，ipc.ping.interval，默认1min</span></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">"The ping interval is"</span> + <span class="keyword">this</span>.pingInterval + <span class="string">"ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.rpcTimeout = remoteId.getRpcTimeout();<span class="comment">//read操作超时，默认0,0时设为pingInterval</span></span><br><span class="line">    UserGroupInformation ticket = remoteId.getTicket();</span><br><span class="line">    Class&lt;?&gt; protocol = remoteId.getProtocol();</span><br><span class="line">    <span class="keyword">this</span>.useSasl = UserGroupInformation.isSecurityEnabled();</span><br><span class="line">    ...<span class="comment">//鉴权相关</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!useSasl) &#123;</span><br><span class="line">        authMethod = AuthMethod.SIMPLE;</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(token != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">        authMethod = AuthMethod.DIGEST;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        authMethod = AuthMethod.KERBEROS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建连接头信息，包括使用的协议，用户和鉴权方法</span></span><br><span class="line">    header = <span class="keyword">new</span> ConnectionHeader(protocol == <span class="keyword">null</span> ? <span class="keyword">null</span> : protocol.getName(), ticket, authMethod);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">    LOG.debug(<span class="string">"Use "</span> + authMethod + <span class="string">" authentication for protocol "</span> + protocol.getSimpleName());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.setName(<span class="string">"IPC Client ("</span> + socketFactory.hashCode() +<span class="string">") connection to "</span> + remoteId.getAddress().toString() +</span><br><span class="line">      <span class="string">" from "</span> + ((ticket==<span class="keyword">null</span>)?<span class="string">"an unknown user"</span>:ticket.getUserName()));</span><br><span class="line">    <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="addCall">addCall</h4><p>获取connection后添加Call对象至connection中:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> addCall(<span class="keyword">Call</span> <span class="keyword">call</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldCloseConnection.get())<span class="comment">//连接应该关闭，不能添加至该连接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    calls.put(<span class="keyword">call</span>.id, <span class="keyword">call</span>);</span><br><span class="line">    notify();<span class="comment">//唤醒在run方法中因为calls为空而在休眠等待的connection线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，addCall可能因为对应的connection要关闭了，而不能添加成功，添加失败时另外查找或创建新的连接，因此需要在do..while循环中，保证循环<br>结束时Call已经添加到一个可用的正常的连接中了。  </p>
<h4 id="setupIOstreams">setupIOstreams</h4><p>由上，获取正常连接后，通过<code>setupIOstreams</code>连接到服务器，并发送rpcHeader和ConnectionHeader，当然，如果已经连接了，便不需要再连接了。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">setupIOstreams</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (socket != <span class="keyword">null</span> || shouldCloseConnection.get()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;<span class="comment">//socket已经存在，表示已经建立了到服务器端的连接，并发送了rpcHeader和ConnectionHeader，直接返回</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Random rand = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      setupConnection();<span class="comment">//连接到远程服务器，每次connect最多20s，最多尝试45次，每次重试间隔1s，即如果连接不上，要等待(20+1)s*45=15min 45s才放弃</span></span><br><span class="line">      InputStream inStream = NetUtils.getInputStream(socket);<span class="comment">//socket输入流，读取响应</span></span><br><span class="line">      OutputStream outStream = NetUtils.getOutputStream(socket);<span class="comment">//socket输出流，发送数据</span></span><br><span class="line">      writeRpcHeader(outStream);<span class="comment">//建立了连接，向服务器写rpcHeader数据，包括4个字节魔数(hrpc)，1个字节版本号(4)，1个字节鉴权方法码</span></span><br><span class="line">      ...<span class="comment">//鉴权相关</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//socket输入流包裹了PingInputStream，在读操作超时时，如果没有设置rpcTimeout，则周期性的(默认1min)发送ping数据到服务器，保持连接，</span></span><br><span class="line">      <span class="comment">//而如果设置了rpcTimeout，则会抛出异常，关闭连接，具体见[概述]PingInputStream</span></span><br><span class="line">      <span class="keyword">this</span>.in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> PingInputStream(inStream)));</span><br><span class="line">      <span class="keyword">this</span>.out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(outStream));</span><br><span class="line">      writeHeader();<span class="comment">//向服务器写连接头，包括协议，用户信息，鉴权方法</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// update last activity time</span></span><br><span class="line">      touch();<span class="comment">//更新本连接上次活动时间lastActivity</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// start the receiver thread after the socket connection has been set up</span></span><br><span class="line">      start();<span class="comment">//开启本线程</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException) &#123;<span class="comment">//连接服务器异常，或者写rpcHeader和连接头异常</span></span><br><span class="line">      markClosed((IOException)t);<span class="comment">//设置shouldCloseConnection为true，然后唤醒阻塞在该连接上的线程(此时应该还没有)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      markClosed(<span class="keyword">new</span> IOException(<span class="string">"Couldn't set up IO streams"</span>, t));</span><br><span class="line">    &#125;</span><br><span class="line">    close();<span class="comment">//关闭连接，从connections中注销，清理资源</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，由<code>setupConnection</code>连接到服务器，然后<code>writeRpcHeader</code>写rpc头，<code>writeHeader</code>写连接头，创建输入输出流之后开启本线程，接收响应。  </p>
<p>连接的输入流包裹了PingInputStream，其read方法如下:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">read</span>() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.<span class="keyword">read</span>();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">        handleTimeout(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>read超时时，由<code>handleTimeout</code>处理超时，而超时时间如果在getProxy中设置rpcTimeout了大于0，则为rpcTimeout，此时pingInterval也为rpcTimeout，<br>否则超时时间为pingInterval(ipc.ping.interval，默认1min)，超时时间设置见后面<code>setupConnection</code>分析。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleTimeout</span>(<span class="params">SocketTimeoutException e</span>) throws IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldCloseConnection.<span class="keyword">get</span>() || !running.<span class="keyword">get</span>() || rpcTimeout &gt; <span class="number">0</span>) &#123;<span class="comment">//如果rpcTimeout大于0，直接抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不应该关闭当前连接且rpcTimeout为0，则周期性发送ping到服务器端</span></span><br><span class="line">      sendPing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> synchronized <span class="keyword">void</span> <span class="title">sendPing</span>(<span class="params"></span>) throws IOException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> curTime = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">if</span> ( curTime - lastActivity.<span class="keyword">get</span>() &gt;= pingInterval) &#123;<span class="comment">//应该发送ping</span></span><br><span class="line">    lastActivity.<span class="keyword">set</span>(curTime);</span><br><span class="line">    synchronized (<span class="keyword">out</span>) &#123;</span><br><span class="line">      <span class="keyword">out</span>.writeInt(PING_CALL_ID);</span><br><span class="line">      <span class="keyword">out</span>.flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上连接超时时，本端连接不应该关闭，如果rpcTimeout大于0，则直接抛出异常，否则发送ping包到服务器，而如果服务器端连接已经关闭，则发送ping<br>时也会抛出异常，异常传递到read方法。因此超时时如果rpcTimeout大于0，或者对端关闭了连接，异常都会传递到read方法。  </p>
<p>后面分析客户端Connection线程接收响应的时，在read*操作上如果抛出异常，则会关闭客户端连接。</p>
<h5 id="setupConnection">setupConnection</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> synchronized <span class="keyword">void</span> <span class="title">setupConnection</span><span class="params">()</span> throws IOException </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> ioFailures = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">short</span> timeoutFailures = <span class="number">0</span>;<span class="comment">//当前连接超时次数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.socket = socketFactory.createSocket();<span class="comment">//通过SocketFactory创建Socket</span></span><br><span class="line">          <span class="keyword">this</span>.socket.setTcpNoDelay(tcpNoDelay);<span class="comment">//开启或禁用Nagel算法，默认开启</span></span><br><span class="line">          ...<span class="comment">//根据鉴权信息，可能绑定本地地址      </span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// connection time out is 20s</span></span><br><span class="line">          NetUtils.connect(<span class="keyword">this</span>.socket, server, <span class="number">20000</span>);<span class="comment">//连接到服务器，最多阻塞20s</span></span><br><span class="line">          <span class="keyword">if</span> (rpcTimeout &gt; <span class="number">0</span>) &#123;<span class="comment">//如果getProxy设置的rpcTimeout大于0，则用rpcTimeout覆盖pingInterval</span></span><br><span class="line">            pingInterval = rpcTimeout;  <span class="comment">// rpcTimeout overwrites pingInterval</span></span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">//设置socket的read超时时间，默认与pingInterval一样，1min，如果rpcTimeout大于0，则为rpcTimeout，此时pingInterval也为rpcTimeout</span></span><br><span class="line">          <span class="keyword">this</span>.socket.setSoTimeout(pingInterval);</span><br><span class="line">          <span class="keyword">return</span>;<span class="comment">//连接建立成功返回</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException toe) &#123;<span class="comment">//连接超时</span></span><br><span class="line">          <span class="keyword">if</span> (updateAddress()) &#123;<span class="comment">//超时后，先尝试更新服务器地址</span></span><br><span class="line">            timeoutFailures = ioFailures = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//若timeoutFailures小于45，则关闭连接(关闭socket)，休眠1s中等待下次继续连接，即最多尝试45次，耗时(20+1)s*45=15min 45s</span></span><br><span class="line">          handleConnectionFailure(timeoutFailures++, <span class="number">45</span>, toe);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">          <span class="comment">//非连接超时造成的IO异常，使用Connection的connectionRetryPolicy判断是否应该重试连接，默认情况下会重试10次，每次间隔也是1s</span></span><br><span class="line">          <span class="keyword">if</span> (updateAddress()) &#123;</span><br><span class="line">            timeoutFailures = ioFailures = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          handleConnectionFailure(ioFailures++, ie);<span class="comment">//connectionRetryPolicy处理重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上通过SocketFactory(所属Client对应的)创建Socket，然后连接到服务器，每次连接最多阻塞20s，如果连接超时，则最多重试45次，每次重试间隔1s，<br>因此如果经过(20+1)s*45=15分钟45s仍然连接超时，则抛出异常。而如果不是连接超时造成的异常，则通过Connection的<code>connectionRetryPolicy</code>进行<br>重试管理，默认重试10次，每次间隔1s。  </p>
<h5 id="writeRpcHeader">writeRpcHeader</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> writeRpcHeader(<span class="type">OutputStream</span> outStream) throws <span class="type">IOException</span> &#123;</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="keyword">out</span> = new <span class="type">DataOutputStream</span>(new <span class="type">BufferedOutputStream</span>(outStream));</span><br><span class="line">    // <span class="type">Write</span> <span class="keyword">out</span> the header, version <span class="keyword">and</span> authentication <span class="keyword">method</span></span><br><span class="line">    <span class="keyword">out</span>.write(<span class="type">Server</span>.<span class="type">HEADER</span>.<span class="type">array</span>());//hrpc，<span class="number">4</span>个字节</span><br><span class="line">    <span class="keyword">out</span>.write(<span class="type">Server</span>.<span class="type">CURRENT_VERSION</span>);//版本<span class="number">4</span>,<span class="number">1</span>个字节</span><br><span class="line">    authMethod.write(<span class="keyword">out</span>);//鉴权方法码，<span class="number">1</span>个字节</span><br><span class="line">    <span class="keyword">out</span>.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，<code>rpcHeader</code>先写4个字节的魔数<code>hrpc</code>，然后是1个字节的版本号(4)，再接着是1个字节鉴权方法码(SIMPLE 80，KERBEROS 81，DIGEST 82)，共计6个字节  </p>
<h5 id="writeHeader">writeHeader</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeHeader</span>(<span class="params"></span>) throws IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out the ConnectionHeader</span></span><br><span class="line">    DataOutputBuffer buf = <span class="keyword">new</span> DataOutputBuffer();</span><br><span class="line">    header.write(buf);<span class="comment">//先将ConnectionHeader写到数据缓冲区中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Write out the payload length</span></span><br><span class="line">    <span class="keyword">int</span> bufLen = buf.getLength();</span><br><span class="line">    <span class="keyword">out</span>.writeInt(bufLen);<span class="comment">//先写header所占长度</span></span><br><span class="line">    <span class="keyword">out</span>.write(buf.getData(), <span class="number">0</span>, bufLen);<span class="comment">//写header序列化实际数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，连接头ConnectionHeader，会先写序列化后所占长度4个字节，然后是header的实际数据，序列化中至少会写出协议，然后根据用户和鉴权方法写<br>相应的值，具体键ConnectionHeader的序列化方法。  </p>
<h3 id="服务器">服务器</h3><p>由上，建立连接时，客户端最终通过socket connect服务器，连接后，发送rpcHeader和ConnectionHeader，来看看对应服务器怎么处理。<br>服务器由<code>RPC.getServer</code>创建服务器后，调用<code>start</code>方法启动listener,handler,responder多个线程。  </p>
<p>处理客户端到来连接请求以及数据请求由listener负责。  </p>
<p>由上服务器的创建<code>getServer</code>过程，创建<code>listener</code>对象时，相应的创建了<code>readThreads</code>个Reader线程，每个Reader有一个Selector。<br>同时，listener的ServerSocketChannel成员<code>acceptChannel</code>注册在Selector成员<code>selector</code>上，且注册为Accept操作。<br>因此成员<code>selector</code>负责到来的连接请求，检测到有连接请求到来时，由acceptChannel执行accept获取SocketChannel得到连接。然后选择一个Reader，<br>将获得的SocketChannel注册到Reader的选择器上，注册Read操作。  </p>
<p>因此，listener的成员<code>selector</code>负责到来的连接请求，而<code>readers</code>负责连接上的数据读取。  </p>
<h4 id="接受连接">接受连接</h4><p>客户端通过socket的connect请求连接，服务器端创建listener时<code>acceptChannel</code>注册在<code>selector</code>上，注册Accept操作，然后在listener线程主程序<br>中监听到来的连接请求。<br>listener线程主程序如下:<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">  LOG.info(getName() + <span class="string">": starting"</span>);</span><br><span class="line">  SERVER.<span class="built_in">set</span>(Server.<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    SelectionKey <span class="variable">key</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      selector.select();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="variable">key</span> = iter.next();</span><br><span class="line">        iter.remove();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable">key</span>.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">key</span>.isAcceptable())</span><br><span class="line">              doAccept(<span class="variable">key</span>);<span class="comment">//有连接请求，doAccept处理</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">key</span> = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//连接数过多导致内存不足或者其他异常，关闭当前连接或者清理所有连接，然后休眠1min</span></span><br><span class="line">  &#125;</span><br><span class="line">  LOG.info(<span class="string">"Stopping "</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">  <span class="comment">//退出时资源清理，包括关闭通道，选择器，关闭所有的连接</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      acceptChannel.close();<span class="comment">//关闭通道</span></span><br><span class="line">      selector.close();<span class="comment">//关闭选择器</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    selector= <span class="keyword">null</span>;</span><br><span class="line">    acceptChannel= <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// clean up all connections</span></span><br><span class="line">    <span class="keyword">while</span> (!connectionList.isEmpty()) &#123;<span class="comment">//关闭所有连接</span></span><br><span class="line">      closeConnection(connectionList.remove(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，客户端有到来的连接时，最终由<code>doAccept</code>处理，传入的key为<code>acceptChannel</code>注册在<code>selector</code>上获取的<code>SelectionKey</code>。  </p>
<h5 id="doAccept">doAccept</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doAccept(SelectionKey <span class="variable">key</span>) <span class="keyword">throws</span> IOException,  OutOfMemoryError &#123;</span><br><span class="line">  Connection c = <span class="keyword">null</span>;</span><br><span class="line">  ServerSocketChannel server = (ServerSocketChannel) <span class="variable">key</span>.channel();<span class="comment">//获取key绑定的通道，为acceptChannel</span></span><br><span class="line">  SocketChannel channel;</span><br><span class="line">  <span class="keyword">while</span> ((channel = server.accept()) != <span class="keyword">null</span>) &#123;<span class="comment">//调用accept得到连接对应的SocketChannel</span></span><br><span class="line">    channel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//新获得的通道配置成非阻塞模式</span></span><br><span class="line">    channel.socket().setTcpNoDelay(tcpNoDelay);<span class="comment">//设置Nagle算法</span></span><br><span class="line">    Reader reader = getReader();<span class="comment">//获取下一个应该使用的Reader，每次从readers数组中读取下一个</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      reader.startAdd();<span class="comment">//将Reader线程从select操作上唤醒，并休眠Reader线程，添加完后再唤醒</span></span><br><span class="line">      SelectionKey readKey = reader.registerChannel(channel);<span class="comment">//在Reader的选择器上注册SocketChannel，注册Read操作</span></span><br><span class="line">      c = <span class="keyword">new</span> Connection(readKey, channel, System.currentTimeMillis());<span class="comment">//创建Connection对象</span></span><br><span class="line">      readKey.attach(c);<span class="comment">//将readKey对应的连接对象Connection作为附件附加在注册的SelectionKey上</span></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionList) &#123;</span><br><span class="line">        connectionList.<span class="built_in">add</span>(numConnections, c);<span class="comment">//添加到connectionList中</span></span><br><span class="line">        numConnections++;<span class="comment">//增加连接数目</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled())</span><br><span class="line">        LOG.debug(<span class="string">"Server connection from "</span> + c.toString() +</span><br><span class="line">            <span class="string">"; # active connections: "</span> + numConnections +</span><br><span class="line">            <span class="string">"; # queued calls: "</span> + callQueue.<span class="built_in">size</span>());          </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      reader.finishAdd();<span class="comment">//唤醒Reader线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>acceptChannel</code>中accept，获得SocketChannel，然后选择一个Reader，注册在Reader的选择器上，注册读操作，并创建该SocketChannel对应的<br>Connection对象，将Connection对象添加到注册所得SelectionKey的附件中。<br>其中的<code>reader.startAdd</code>，如果该Reader线程阻塞在select操作上，唤醒它，然后将<code>adding</code>至为true，导致线程睡眠<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">startAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    adding = <span class="keyword">true</span>;</span><br><span class="line">    readSelector.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的Reader线程主程序:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          readSelector.select();<span class="comment">//如果当前线程阻塞在此，readSelector.wakeup将唤醒，直接返回</span></span><br><span class="line">          <span class="keyword">while</span> (adding) &#123;<span class="comment">//adding置true，等待1s，等待添加完成</span></span><br><span class="line">            <span class="keyword">this</span>.wait(<span class="number">1000</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>添加完成后的finally中<code>reader.finishAdd</code>，通知睡眠的Reader线程，并将adding置false<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">finishAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    adding = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.notify();<span class="comment">//唤醒在wait中的线程  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，服务器端便处理了客户端的connect请求，创建SocketChannel对象，注册到Reader线程的选择器中，创建Connection对象，附加到SelectionKey中，<br>然后由Reader操作负责读取带来的数据请求。  </p>
<h4 id="处理头数据">处理头数据</h4><p>由上，客户端连接上服务器后，会先发送<code>rpcHeader</code>和<code>ConnectionHeader</code>给服务器，接下来看看服务器怎么处理。  </p>
<p>如上，服务器对连接上的数据请求由Reader线程处理，Reader线程的主程序:<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">    LOG.info(<span class="string">"Starting SocketReader"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        SelectionKey <span class="variable">key</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          readSelector.select();<span class="comment">//select操作</span></span><br><span class="line">          <span class="keyword">while</span> (adding) &#123;<span class="comment">//正在添加SocketChannel，休眠，添加完后会被唤醒</span></span><br><span class="line">            <span class="keyword">this</span>.wait(<span class="number">1000</span>);</span><br><span class="line">          &#125;              </span><br><span class="line">          Iterator&lt;SelectionKey&gt; iter = readSelector.selectedKeys().iterator();</span><br><span class="line">          <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="variable">key</span> = iter.next();</span><br><span class="line">            iter.remove();</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">key</span>.isValid()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="variable">key</span>.isReadable()) &#123;</span><br><span class="line">                doRead(<span class="variable">key</span>);<span class="comment">//处理key对应的数据请求</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">key</span> = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ...<span class="comment">//异常处理，进行日志记录</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，开始部分对应建立连接过程中添加SocketChannel到Reader中的逻辑，上面已经分析过。之后对于到来的数据请求，通过<code>doRead</code>处理，key为<br>SocketChannel注册到选择器上的key，且包含附件Connection。  </p>
<h5 id="doRead">doRead</h5><p>其实doRead操作不仅处理头数据，还处理实际的调用请求数据，这里我们先分析头数据的处理过程。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void doRead(<span class="type">SelectionKey</span> key) <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">    int <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="built_in">c</span> = (<span class="type">Connection</span>)key.attachment();<span class="comment">//获取附件，连接对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">c</span> == null) &#123;<span class="comment">//没有附件，异常，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">c</span>.setLastContact(<span class="type">System</span>.currentTimeMillis());<span class="comment">//更新客户端和服务器通信时间lastContact</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">count</span> = <span class="built_in">c</span>.readAndProcess();<span class="comment">//读数据并处理</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> ieo) &#123;<span class="comment">//中断异常，在Reader的主程序中会进行日志记录</span></span><br><span class="line">        <span class="type">LOG</span>.info(getName() + <span class="string">": readAndProcess caught InterruptedException"</span>, ieo);</span><br><span class="line">        <span class="keyword">throw</span> ieo;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;<span class="comment">//鉴权失败异常导致关闭连接</span></span><br><span class="line">        <span class="type">LOG</span>.info(getName() + <span class="string">": readAndProcess threw exception "</span> + e + <span class="string">". Count of bytes read: "</span> + <span class="built_in">count</span>, e);</span><br><span class="line">        <span class="built_in">count</span> = -<span class="number">1</span>; <span class="comment">//so that the (count &lt; 0) block is executed</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">count</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">LOG</span>.isDebugEnabled())</span><br><span class="line">          <span class="type">LOG</span>.debug(getName() + <span class="string">": disconnecting client "</span> + <span class="built_in">c</span> + <span class="string">". Number of active connections: "</span>+ numConnections);</span><br><span class="line">        closeConnection(<span class="built_in">c</span>);</span><br><span class="line">        <span class="built_in">c</span> = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常情况，更新通信时间。这里注意，count大于0时只表明读取到了数据，可能为部分数据还未处理，需要等待下一次读取操作，也可能</span></span><br><span class="line">    <span class="comment">//读取了一个请求的所有数据，并进行了处理。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">c</span>.setLastContact(<span class="type">System</span>.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="readAndProcess">readAndProcess</h4><p>readAndProcess根据标识<code>rpcHeaderRead</code>和<code>headerRead</code>两个标识，分别进行不同的处理。<br>若<code>rpcHeaderRead</code>为false，则应该先读取并处理<code>rpcHeader</code>数据。当<code>rpcHeaderRead</code>为true时，若<code>headerRead</code>为false，则还需读取并处理<br>ConnectionHeader数据。当<code>rpcHeader</code>和<code>headerRead</code>都为true时，则进入到实际调用请求数据的处理过程。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> readAndProcess() <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* Read at most one RPC. If the header is not read completely yet</span><br><span class="line">     * then iterate until we read first RPC or until there is no data left.</span><br><span class="line">     */</span>    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dataLengthBuffer.remaining() &gt; <span class="number">0</span>) &#123;<span class="comment">//dataLengthBuffer为4个字节</span></span><br><span class="line">      <span class="comment">//读取数据到缓冲区dataLengthBuffer中，尽可能填充完缓冲区剩余部分，不过不保证一定能填充完，未填充完时直接返回，等待下一次读取操作</span></span><br><span class="line">      <span class="keyword">count</span> = channelRead(channel, dataLengthBuffer);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span> || dataLengthBuffer.remaining() &gt; <span class="number">0</span>) <span class="comment">//读取错误或者没有填充完缓冲区，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!rpcHeaderRead) &#123;<span class="comment">//还未处理rpcHeader</span></span><br><span class="line">      <span class="comment">//Every connection is expected to send the header.</span></span><br><span class="line">      <span class="comment">//2字节缓冲，rpcHeader总共6字节，魔数4字节现在保存在dataLengthBuffer中，rpcHeaderBuffer保存版本号和鉴权方法码</span></span><br><span class="line">      <span class="keyword">if</span> (rpcHeaderBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rpcHeaderBuffer = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">count</span> = channelRead(channel, rpcHeaderBuffer);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span> || rpcHeaderBuffer.remaining() &gt; <span class="number">0</span>) &#123;<span class="comment">//同上，缓冲区读完才会继续处理，否则直接返回读取到的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> version = rpcHeaderBuffer.get(<span class="number">0</span>);<span class="comment">//第一字节为版本号(4)</span></span><br><span class="line">      <span class="keyword">byte</span>[] method = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;rpcHeaderBuffer.get(<span class="number">1</span>)&#125;;<span class="comment">//第二个字节为鉴权方法码</span></span><br><span class="line">      authMethod = AuthMethod.<span class="keyword">read</span>(<span class="keyword">new</span> DataInputStream( <span class="keyword">new</span> ByteArrayInputStream(method)));</span><br><span class="line">      dataLengthBuffer.flip();<span class="comment">//          </span></span><br><span class="line">      <span class="keyword">if</span> (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) &#123;<span class="comment">//验证魔数hrpc和版本号，正确的话才会继续处理，否则关闭连接</span></span><br><span class="line">        <span class="comment">//Warning is ok since this is not supposed to happen.</span></span><br><span class="line">        LOG.warn(<span class="string">"Incorrect header or version mismatch from "</span> + </span><br><span class="line">                 hostAddress + <span class="string">":"</span> + remotePort +</span><br><span class="line">                 <span class="string">" got version "</span> + version + </span><br><span class="line">                 <span class="string">" expected version "</span> + CURRENT_VERSION);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//返回-1时，关闭连接</span></span><br><span class="line">      &#125;</span><br><span class="line">      dataLengthBuffer.clear();</span><br><span class="line">      <span class="keyword">if</span> (authMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unable to read authentication method"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isSecurityEnabled &amp;&amp; authMethod == AuthMethod.SIMPLE) &#123;</span><br><span class="line">        AccessControlException ae = <span class="keyword">new</span> AccessControlException(<span class="string">"Authorization ("</span></span><br><span class="line">          + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION</span><br><span class="line">          + <span class="string">") is enabled but authentication ("</span></span><br><span class="line">          + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION</span><br><span class="line">          + <span class="string">") is configured as simple. Please configure another method "</span></span><br><span class="line">          + <span class="string">"like kerberos or digest."</span>);</span><br><span class="line">        <span class="comment">//鉴权失败，发送响应，对应的Call id为-1，状态为致命错误，发送异常类和异常信息。客户端读取到该响应时关闭连接</span></span><br><span class="line">        setupResponse(authFailedResponse, authFailedCall, Status.FATAL,<span class="keyword">null</span>, ae.getClass().getName(), ae.getMessage());</span><br><span class="line">        responder.doRespond(authFailedCall);<span class="comment">//添加到响应队列中，并相应处理</span></span><br><span class="line">        <span class="keyword">throw</span> ae;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isSecurityEnabled &amp;&amp; authMethod != AuthMethod.SIMPLE) &#123;</span><br><span class="line">        doSaslReply(SaslStatus.SUCCESS, <span class="keyword">new</span> IntWritable(</span><br><span class="line">            SaslRpcServer.SWITCH_TO_SIMPLE_AUTH), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        authMethod = AuthMethod.SIMPLE;</span><br><span class="line">        <span class="comment">// client has already sent the initial Sasl message and we</span></span><br><span class="line">        <span class="comment">// should ignore it. Both client and server should fall back</span></span><br><span class="line">        <span class="comment">// to simple auth from now on.</span></span><br><span class="line">        skipInitialSaslHandshake = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (authMethod != AuthMethod.SIMPLE) &#123;</span><br><span class="line">        useSasl = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      rpcHeaderBuffer = <span class="keyword">null</span>;</span><br><span class="line">      rpcHeaderRead = <span class="keyword">true</span>;<span class="comment">//正常情况读完rpcHeaderRead并验证</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">      dataLengthBuffer.flip();</span><br><span class="line">      dataLength = dataLengthBuffer.getInt();<span class="comment">//处理完了rpcHeaderRead，则dataLengthBuffer中保存的为接下来的数据长度或ping数据(-1)</span></span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (dataLength == Client.PING_CALL_ID) &#123;<span class="comment">//客户端发送的ping数据-1</span></span><br><span class="line">        <span class="keyword">if</span>(!useWrap) &#123; <span class="comment">//covers the !useSasl too</span></span><br><span class="line">          dataLengthBuffer.clear();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//ping message，返回0时，会更新连接时间lastContact</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这之后的便是数据长度了</span></span><br><span class="line">      <span class="keyword">if</span> (dataLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Unexpected data length "</span> + dataLength + <span class="string">"!! from "</span> + </span><br><span class="line">            getHostAddress());</span><br><span class="line">      &#125;</span><br><span class="line">      data = ByteBuffer.allocate(dataLength);<span class="comment">//根据数据长度分配data缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">count</span> = channelRead(channel, data);<span class="comment">//从通道尽可能读取足够填充缓冲区剩余空间的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data.remaining() == <span class="number">0</span>) &#123;<span class="comment">//缓冲区没有剩余空间了，即发送过来的一个帧的数据读取玩，开始处理</span></span><br><span class="line">      dataLengthBuffer.clear();</span><br><span class="line">      data.flip();</span><br><span class="line">      <span class="keyword">if</span> (skipInitialSaslHandshake) &#123;</span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line">        skipInitialSaslHandshake = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> isHeaderRead = headerRead;</span><br><span class="line">      <span class="keyword">if</span> (useSasl) &#123;<span class="comment">//简单鉴权，这里不分析</span></span><br><span class="line">        saslReadAndProcess(data.array());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//处理一个帧数据</span></span><br><span class="line">        processOneRpc(data.array());</span><br><span class="line">      &#125;</span><br><span class="line">      data = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!isHeaderRead) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//这里隐含缓冲区还有剩余空间，即一个帧数据未读取玩，直接返回读取到的字节数，更新lastContact，等待下一次读取</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上，如果rpcHeaderRead为false时，需要处理rpcHeader，这时根据发送端发送过来的rpcHeader格式:<br><code>4字节魔数hrpc+1字节版本号+1字节鉴权方法码</code><br>这是dataLengthBuffer里面保存的便是魔数hrpc，然后分配两个字节大小的rpcHeaderBuffer保存剩下的版本号和鉴权方法码，进行相应的验证。  </p>
<p>而如果rpcHeader已经处理了，则一般情况下dataLengthBuffer里面保存的为一个帧数据的长度，根据这个长度分配data缓冲区的大小，然后进行相应长度<br>数据的读取。不过在建立连接后，客户端read服务器响应超时时，客户端会发送ping数据，以保持连接，该ping数据作为一帧数据来看的话为int值-1，所以<br>如果dataLengthBuffer值为-1时，则是客户端的ping数据，这时简单的返回0，然后更新连接时间即可。<br>所有上面提到的缓冲区都要注意的是，<code>channelRead</code>会尽量从通道读取数据填满缓冲区，但也不能保证。当缓冲区还有剩余空间时，我们还需等待下一数据<br>读取操作的到来，这时简单的返回读取到的数据大小，更新连接时间即可。相应缓冲区填满后，才能进行相应的处理。  </p>
<p><code>channelRead</code>方法会尽量从通道中读取足够多的数据以填满缓冲区，但不保证。当缓冲区剩余空间大于<code>NIO_BUFFER_LIMIT</code>(8KB)时，会循环从通道读取<br>数据到缓冲区，每次读取NIO_BUFFER_LIMIT大小，按照注释是说能够避免JDK在缓冲区增长时分配太多的直接内存缓冲，但是这里应该不会增长，只是读取<br>最大为剩余空间的数据到缓冲区。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> channelRead(ReadableByteChannel channel, ByteBuffer buffer) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = (buffer.remaining() &lt;= NIO_BUFFER_LIMIT) ? channel.<span class="keyword">read</span>(buffer) : channelIO(channel, <span class="keyword">null</span>, buffer);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      rpcMetrics.incrReceivedBytes(<span class="keyword">count</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//channelRead和channelWrite同时使用，读时writeCh为null，写时readCh为null。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> channelIO(ReadableByteChannel readCh, WritableByteChannel writeCh, ByteBuffer buf) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">int</span> originalLimit = buf.limit();</span><br><span class="line">    <span class="keyword">int</span> initialRemaining = buf.remaining();</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ioSize = Math.min(buf.remaining(), NIO_BUFFER_LIMIT);<span class="comment">//一次读取到缓冲区的数据大小，最多8KB</span></span><br><span class="line">        buf.limit(buf.position() + ioSize);<span class="comment">//设置新的limit值为position+要读取的大小</span></span><br><span class="line">        </span><br><span class="line">        ret = (readCh == <span class="keyword">null</span>) ? writeCh.<span class="keyword">write</span>(buf) : readCh.<span class="keyword">read</span>(buf); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ret &lt; ioSize) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        buf.limit(originalLimit);<span class="comment">//设为原来的limit值        </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nBytes = initialRemaining - buf.remaining(); </span><br><span class="line">    <span class="keyword">return</span> (nBytes &gt; <span class="number">0</span>) ? nBytes : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理完rpcHeader和ping包后，由<code>processOneRpc</code>处理到来的数据帧，一帧数据已经保存在data缓冲区中了。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">processOneRpc</span><span class="params">(<span class="keyword">byte</span>[] buf)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (headerRead) &#123;</span><br><span class="line">    processData(buf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processHeader(buf);</span><br><span class="line">    headerRead = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!authorizeConnection()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AccessControlException(<span class="string">"Connection from "</span> + <span class="keyword">this</span></span><br><span class="line">          + <span class="string">" for protocol "</span> + header.getProtocol()</span><br><span class="line">          + <span class="string">" is unauthorized for user "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，如果headerRead为false，即还未读取连接头，则通过<code>processHeader</code>处理连接头，并通过<code>authorizeConnection</code>根据鉴权方法以及相关<br>信息进行鉴权。否则若连接头已经处理，则通过<code>processData</code>处理实际调用请求数据。这里在连接过程，先分析连接头的处理，实际的调用请求数据处理见后。  </p>
<h4 id="processHeader">processHeader</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processHeader</span>(<span class="params"><span class="keyword">byte</span>[] buf</span>) throws IOException </span>&#123;</span><br><span class="line">  DataInputStream <span class="keyword">in</span> = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(buf));</span><br><span class="line">  header.readFields(<span class="keyword">in</span>);<span class="comment">//反序列化连接头对象</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String protocolClassName = header.getProtocol();<span class="comment">//获取客户端请求的协议</span></span><br><span class="line">    <span class="keyword">if</span> (protocolClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      protocol = getProtocolClass(header.getProtocol(), conf);<span class="comment">//初始化该连接对应的协议类</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown protocol: "</span> + header.getProtocol());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  UserGroupInformation protocolUser = header.getUgi();<span class="comment">//获取客户端的用户信息</span></span><br><span class="line">  ...<span class="comment">//初始化连接的user成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接的鉴权方法<code>authMethod</code>在处理rpcHeader时已经初始化了，这里反序列化连接头后，从连接头中获知客户端请求连接的协议，然后初始化该连接的<br><code>protocol</code>，以及根据连接头的用户信息，初始化该连接的<code>user</code>成员。  </p>
<p>初始化相关成员后，使用<code>authorizedConnection</code>对客户端进行鉴权<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">authorizeConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// If auth method is DIGEST, the token was obtained by the</span></span><br><span class="line">    <span class="comment">// real user for the effective user, therefore not required to</span></span><br><span class="line">    <span class="comment">// authorize real user. doAs is allowed only for simple or kerberos</span></span><br><span class="line">    <span class="comment">// authentication</span></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span> &amp;&amp; user.getRealUser() != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (authMethod != AuthMethod.DIGEST)) &#123;</span><br><span class="line">      ProxyUsers.authorize(user, <span class="keyword">this</span>.getHostAddress(), conf);</span><br><span class="line">    &#125;</span><br><span class="line">    authorize(user, header, getHostInetAddress());</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">"Successfully authorized "</span> + header);</span><br><span class="line">    &#125;</span><br><span class="line">    rpcMetrics.incrAuthorizationSuccesses();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (AuthorizationException ae) &#123;</span><br><span class="line">    rpcMetrics.incrAuthorizationFailures();</span><br><span class="line">    <span class="comment">//鉴权异常失败，发送鉴权异常响应，对应Call为-1，状态FATAL，发送异常类和异常信息</span></span><br><span class="line">    setupResponse(authFailedResponse, authFailedCall, Status.FATAL, <span class="keyword">null</span>, ae.getClass().getName(), ae.getMessage());</span><br><span class="line">    responder.doRespond(authFailedCall);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果鉴权失败，则发送鉴权异常响应，对应状态为FATAL，客户端会关闭连接。而在服务器端，在<code>processOneRpc</code>中抛出<code>AccessControlException</code>这个<br><code>IOException</code>最终传递到<code>doRead</code>中的<code>readAndProcess</code>中，由catch捕获，将<code>count</code>即读取到的数据大小置为-1，后续处理中关闭服务器端连接。<br>doRead中IOException异常处理见上。  </p>
<p>因此，我们这里分析了服务器端连接建立的过程，由监听器listener监听到来的连接，并注册到Reader线程的选择器中，由Reader线程处理到来的数据请求。<br>客户端数据到来时，与客户端发送数据流程对应的，服务器端先处理rpcHeader，判断魔数和版本号是否相符，不相符的话给客户端发送鉴权失败异常响应，<br>该响应对应的Call对象固定，其id为-1，状态为FATAL，客户端将会关闭连接，而服务器置读取到的数据count为-1，也关闭连接。正常的话初始化连接的<br>authMethod成员。这里注意魔数hrpc长度为4个字节，刚好保存在后续用来保存一个帧数据长度的缓冲区dataLengthBuffer中。  </p>
<p>处理完rpcHeader之后，便是对一帧数据的处理。一帧数据可能为ping数据，为4个字节值为-1，这时简单的置读取到数据count为0，更新连接时间lastContact。  </p>
<p>否则dataLengthBuffer便是一帧数据的长度，根据该长度分配data缓冲区。<br>此时一帧数据可能为连接头，可能为实际的调用请求数据。没有读取连接头的话，则接下来的一帧数据为连接头。<br>对连接头进行处理，读取发送过来的连接头初始化该连接的<code>protocol</code>和<code>user</code>，然后根据不同的鉴权方式进行鉴权，鉴权失败，发送Call id为-1的响应，相应<br>状态为FATAL，客户端关闭连接，而这里服务器抛出IOException，在doRead的异常处理中置<code>count</code>为-1，关闭服务器端连接。  </p>
<p>处理完这些信息后，连接建立了，鉴权完成了，可以在该连接上进行正常的调用请求了。具体过程见<a href="./RPC源码分析下篇">下篇</a>。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Common/" rel="tag">#Common</a>
          
            <a href="/tags/Hadoop-1-2-1/" rel="tag">#Hadoop-1.2.1</a>
          
            <a href="/tags/RPC/" rel="tag">#RPC</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/配置相关RPC/" rel="next" title="Hadoop配置相关---RPC">
                <i class="fa fa-chevron-left"></i> Hadoop配置相关---RPC
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/RPC源码分析下篇/" rel="prev" title="RPC源码阅读---源码分析下篇">
                RPC源码阅读---源码分析下篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


        </div>

        


        
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="RPC源码分析上篇/"
           data-title="RPC源码阅读---源码分析上篇" data-url="http://xiao-yun.github.io/RPC源码分析上篇/">
      </div>
    
  </div>


      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/hero.jpg" alt="xiaoyun" itemprop="image"/>
          <p class="site-author-name" itemprop="name">xiaoyun</p>
        </div>
        <p class="site-description motion-element" itemprop="description">学习笔记，网上资源摘要等</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiao-yun" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端代理创建"><span class="nav-number">1.</span> <span class="nav-text">客户端代理创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器创建"><span class="nav-number">2.</span> <span class="nav-text">服务器创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#监听器构造"><span class="nav-number">2.1.</span> <span class="nav-text">监听器构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应器构建"><span class="nav-number">2.2.</span> <span class="nav-text">响应器构建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器启动"><span class="nav-number">3.</span> <span class="nav-text">服务器启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理方法调用"><span class="nav-number">4.</span> <span class="nav-text">代理方法调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建立连接"><span class="nav-number">5.</span> <span class="nav-text">建立连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端"><span class="nav-number">5.1.</span> <span class="nav-text">客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection构造"><span class="nav-number">5.1.1.</span> <span class="nav-text">Connection构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addCall"><span class="nav-number">5.1.2.</span> <span class="nav-text">addCall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setupIOstreams"><span class="nav-number">5.1.3.</span> <span class="nav-text">setupIOstreams</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#setupConnection"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">setupConnection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#writeRpcHeader"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">writeRpcHeader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#writeHeader"><span class="nav-number">5.1.3.3.</span> <span class="nav-text">writeHeader</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器"><span class="nav-number">5.2.</span> <span class="nav-text">服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接受连接"><span class="nav-number">5.2.1.</span> <span class="nav-text">接受连接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#doAccept"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">doAccept</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理头数据"><span class="nav-number">5.2.2.</span> <span class="nav-text">处理头数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#doRead"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">doRead</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readAndProcess"><span class="nav-number">5.2.3.</span> <span class="nav-text">readAndProcess</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#processHeader"><span class="nav-number">5.2.4.</span> <span class="nav-text">processHeader</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoyun</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xiaoyuncom"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    motionMiddleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');
      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    };
  });
</script>



  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
